#+title: Swift miniapps
#+date: 2025-08-25T16:36:38
#+draft: true

Creating native macOS applications with Swift can be surprisingly straightforward, especially when you need to wrap web content in a native container. Let's explore a minimal Swift WebKit application that demonstrates bidirectional communication between JavaScript and native Swift code.

* Building a WebKit-Based Browser

The application creates a native macOS window with an embedded WebView, perfect for local development servers or web-based applications that need native integration.

#+begin_src swift :tangle web.swift
import Cocoa
import WebKit

class App: NSObject, NSApplicationDelegate, WKScriptMessageHandler, WKNavigationDelegate {
    var win:NSWindow!
    var web:WKWebView!

    func applicationDidFinishLaunching(_ n: Notification) {
        // 1) Setup menu bar
        setupMenuBar()
        
        // 2) Configure a JS bridge named "app"
        let ucc = WKUserContentController()
        ucc.add(self, name: "app")
        let js = """
        window.sendToSwift = (data) =>
          window.webkit.messageHandlers.app.postMessage(data);
        console.log('Injected bridge ready');
        """
        ucc.addUserScript(.init(source: js, injectionTime: .atDocumentStart, forMainFrameOnly: true))

        let cfg = WKWebViewConfiguration(); cfg.userContentController = ucc

        // 3) Window + WebView
        win = NSWindow(contentRect: NSMakeRect(0,0,900,700), styleMask: [.titled,.closable,.resizable,.fullSizeContentView], backing: .buffered, defer: false)
        win.collectionBehavior = [.fullScreenPrimary]
        web = WKWebView(frame: .zero, configuration: cfg)
        web.navigationDelegate = self
        win.contentView = web
        win.center(); win.title = "Web Browser"; win.makeKeyAndOrderFront(nil)

        // 4) Parse command line arguments
        var url = "http://localhost:3000"
        var startFullScreen = false
        
        for (index, arg) in CommandLine.arguments.enumerated() {
            if arg == "--fullscreen" || arg == "-f" {
                startFullScreen = true
            } else if index == 1 && !arg.hasPrefix("-") {
                url = arg
            }
        }
        
        // 5) Load URL and handle fullscreen
        web.load(URLRequest(url: URL(string: url)!))
        
        if startFullScreen {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.win.toggleFullScreen(nil)
            }
        }
    }

    // JS -> Swift
    func userContentController(_ u: WKUserContentController, didReceive m: WKScriptMessage) {
        print("JS sent:", m.body) // do whatever you want with the data
        // Example: reply back to JS
        web.evaluateJavaScript("console.log('Swift got your message: \(String(describing: m.body))')")
    }

    // Page finished loading: Swift -> JS
    func webView(_ webView: WKWebView, didFinish nav: WKNavigation!) {
        // Call into JS on the page
        web.evaluateJavaScript("""
          document.title = 'Loaded via Swift';
          if (window.sendToSwift) sendToSwift({type:'ready', time: Date.now()});
          'ok'
        """) { result, error in
            if let error = error { print("JS error:", error) }
            else { print("JS result:", result ?? "nil") }
        }
    }

    func applicationShouldTerminateAfterLastWindowClosed(_ app: NSApplication) -> Bool {
        return true
    }
    
    func setupMenuBar() {
        let mainMenu = NSMenu()
        
        // App menu
        let appMenuItem = NSMenuItem()
        mainMenu.addItem(appMenuItem)
        
        let appMenu = NSMenu()
        appMenuItem.submenu = appMenu
        
        let quitMenuItem = NSMenuItem(title: "Quit Web Browser", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q")
        appMenu.addItem(quitMenuItem)
        
        NSApplication.shared.mainMenu = mainMenu
    }
}

let app = NSApplication.shared
let delegate = App()
app.delegate = delegate
app.setActivationPolicy(.regular)
app.activate(ignoringOtherApps: true)
app.run()
#+end_src

* Key Features

** JavaScript Bridge
The application injects a =sendToSwift= function into every loaded page, enabling JavaScript to communicate with the native Swift code. Messages are handled through the =WKScriptMessageHandler= protocol.

** Command Line Arguments
- First argument: URL to load (defaults to =http://localhost:3000=)
- =--fullscreen= or =-f=: Start in fullscreen mode

** Bidirectional Communication
- JavaScript ‚Üí Swift: =window.sendToSwift(data)=
- Swift ‚Üí JavaScript: =evaluateJavaScript= method

* Usage

Compile and run:
#+begin_src bash
swift web.swift
#+end_src

With custom URL:
#+begin_src bash
swift web.swift https://example.com
#+end_src

Fullscreen mode:
#+begin_src bash
swift web.swift --fullscreen
#+end_src

This approach is perfect for local development servers, Electron-style applications, or any scenario where you need a native wrapper around web content with native integration capabilities.

* Testing the Bridge

Here's a complete HTML test page that demonstrates the JavaScript bridge functionality:

#+begin_src html :tangle index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swift WebKit Bridge Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        input, textarea {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin: 5px 0;
            width: 100%;
            box-sizing: border-box;
        }
        
        input::placeholder, textarea::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        #log {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 15px;
            min-height: 200px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .status {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status.connected {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .status.waiting {
            background: rgba(255, 152, 0, 0.3);
            border: 1px solid rgba(255, 152, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Swift WebKit Bridge Test</h1>
        
        <div id="bridge-status" class="status waiting">
            üîÑ Waiting for Swift bridge...
        </div>
        
        <h2>Send Messages to Swift</h2>
        
        <div>
            <input type="text" id="messageInput" placeholder="Enter message to send to Swift" value="Hello from JavaScript!">
            <button onclick="sendSimpleMessage()">Send Simple Message</button>
        </div>
        
        <div>
            <button onclick="sendObjectMessage()">Send Object Message</button>
            <button onclick="sendTimestamp()">Send Timestamp</button>
            <button onclick="sendUserInfo()">Send User Info</button>
        </div>
        
        <div>
            <textarea id="customJson" placeholder="Enter custom JSON to send" rows="3">{"type": "custom", "data": {"hello": "world"}}</textarea>
            <button onclick="sendCustomJson()">Send Custom JSON</button>
        </div>
        
        <div>
            <button onclick="clearLog()">Clear Log</button>
            <button onclick="testBridgeAvailability()">Test Bridge</button>
        </div>
        
        <h2>Message Log</h2>
        <div id="log"></div>
    </div>

    <script>
        let logElement = document.getElementById('log');
        let bridgeStatusElement = document.getElementById('bridge-status');
        
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function sendSimpleMessage() {
            const message = document.getElementById('messageInput').value;
            if (window.sendToSwift) {
                window.sendToSwift(message);
                log(`Sent simple message: "${message}"`);
            } else {
                log('ERROR: sendToSwift function not available');
            }
        }
        
        function sendObjectMessage() {
            const data = {
                type: 'object_message',
                content: 'This is an object message',
                timestamp: Date.now(),
                random: Math.floor(Math.random() * 1000)
            };
            
            if (window.sendToSwift) {
                window.sendToSwift(data);
                log(`Sent object: ${JSON.stringify(data, null, 2)}`);
            } else {
                log('ERROR: sendToSwift function not available');
            }
        }
        
        function testBridgeAvailability() {
            if (window.sendToSwift) {
                log('‚úÖ Bridge is available and ready');
                window.sendToSwift({
                    type: 'bridge_test',
                    message: 'Testing bridge connectivity',
                    timestamp: Date.now()
                });
            } else {
                log('‚ùå Bridge is not available');
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ Page loaded, testing bridge...');
            setTimeout(testBridgeAvailability, 100);
        });
    </script>
</body>
</html>
#+end_src

The test page provides several ways to test the bridge:
- Simple string messages
- Complex object messages with multiple data types
- Custom JSON input for testing specific scenarios
- Real-time bridge availability detection

To test locally, save as =index.html= and run:
#+begin_src bash
swift web.swift file:///path/to/index.html
#+end_src

* References
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
# End:
