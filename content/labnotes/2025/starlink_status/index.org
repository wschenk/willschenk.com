#+title: Starlink status
#+date: 2025-08-27T10:53:00
#+draft: true

I have a starlink mini in my car, which is cool, but 
#+begin_src bash
  brew install grpcurl

#+end_src

Then ask it

#+begin_src bash :results output
  grpcurl -plaintext -d '{"get_status":{}}' 192.168.100.1:9200 SpaceX.API.Device.Device/Handle
#+end_src

#+RESULTS:
#+begin_example
{
  "apiVersion": "38",
  "dishGetStatus": {
    "deviceInfo": {
      "id": "ut00680106-87c1011c-d886d132",
      "hardwareVersion": "mini1_prod2",
      "softwareVersion": "2025.08.09.mr61440",
      "countryCode": "US",
      "utcOffsetS": -18000,
      "bootcount": 1926,
      "generationNumber": "1755210683",
      "buildId": "acae5ab4-4e25-41a0-940d-b35679292f9f.uterm_catapult_manifest.release"
    },
    "deviceState": {
      "uptimeS": "386"
    },
    "obstructionStats": {
      "fractionObstructed": 0.0019607844,
      "validS": 283,
      "avgProlongedObstructionIntervalS": "NaN",
      "patchesValid": 1530
    },
    "alerts": {
      "roaming": true
    },
    "downlinkThroughputBps": 173249.92,
    "uplinkThroughputBps": 129285.23,
    "popPingLatencyMs": 22.115126,
    "boresightAzimuthDeg": 150.57686,
    "boresightElevationDeg": 87.59529,
    "gpsStats": {
      "gpsValid": true,
      "gpsSats": 14
    },
    "ethSpeedMbps": 1000,
    "mobilityClass": "MOBILE",
    "isSnrAboveNoiseFloor": true,
    "readyStates": {
      "scp": true,
      "l1l2": true,
      "xphy": true,
      "aap": true,
      "rf": true
    },
    "softwareUpdateState": "IDLE",
    "hasActuators": "HAS_ACTUATORS_NO",
    "disablementCode": "OKAY",
    "hasSignedCals": true,
    "softwareUpdateStats": {
      "softwareUpdateState": "IDLE"
    },
    "alignmentStats": {
      "hasActuators": "HAS_ACTUATORS_NO",
      "tiltAngleDeg": 3.0369658,
      "boresightAzimuthDeg": 150.57686,
      "boresightElevationDeg": 87.59529,
      "attitudeEstimationState": "FILTER_UNCONVERGED",
      "attitudeUncertaintyDeg": 9.899634,
      "desiredBoresightAzimuthDeg": 63.097248,
      "desiredBoresightElevationDeg": 67.00226
    },
    "initializationDurationSeconds": {
      "attitudeInitialization": 40,
      "burstDetected": 40,
      "ekfConverged": 40,
      "firstCplane": 42,
      "firstPopPing": 57,
      "gpsValid": 28,
      "initialNetworkEntry": 41,
      "networkSchedule": 46,
      "rfReady": 24,
      "stableConnection": 1
    },
    "secondsUntilSwupdateRebootPossible": -1,
    "connectedRouters": [
      "Router-0100000000000000009993AC"
    ],
    "plcStats": {
      "port1Stats": {},
      "port2Stats": {},
      "port3Stats": {}
    },
    "upsuStats": {},
    "dlBandwidthRestrictedReason": "NO_LIMIT",
    "ulBandwidthRestrictedReason": "NO_LIMIT",
    "apsStats": {},
    "ned2dishQuaternion": {
      "qScalar": 0.020956341,
      "qX": -0.5348239,
      "qY": -0.84470296,
      "qZ": 0.0010677704
    },
    "downstreamRouters": {
      "Router-0100000000000000009993AC": {
        "role": "CONTROLLER",
        "lastSeen": "1756306451069660042"
      }
    },
    "config": {
      "swupdateRebootHour": 3,
      "applySnowMeltMode": true,
      "applyLocationRequestMode": true,
      "applyLevelDishMode": true,
      "applyPowerSaveStartMinutes": true,
      "applyPowerSaveDurationMinutes": true,
      "applyPowerSaveMode": true,
      "applySwupdateThreeDayDeferralEnabled": true,
      "applyAssetClass": true,
      "applySwupdateRebootHour": true
    }
  }
}
#+end_example

* Starlink Monitoring Flow

#+begin_src mermaid
flowchart TD
    A[Start Monitoring] --> B[Query Starlink API<br/>192.168.100.1:9200]
    B --> C{API Response?}
    
    C -->|Success| D[Parse JSON Status]
    C -->|Failed| E[Connection Error<br/>Show: ‚ùå Error/üì° Offline]
    
    D --> F{Check Outage Field}
    F -->|Has Outage| G{Outage Cause}
    F -->|No Outage| H[Status: Online ‚úÖ]
    
    G -->|BOOTING| I[Status: Booting üîÑ<br/>Show: Device starting up]
    G -->|NO_PINGS| J[Status: Network Issues üì°<br/>Show: Connection problems]
    G -->|Other| K[Status: Service Issue ‚ö†Ô∏è<br/>Show: Outage detected]
    
    H --> L[Check Performance Metrics]
    I --> M[Monitor Boot Progress]
    J --> N[Monitor Network Recovery]
    K --> N
    E --> O[Wait and Retry]
    
    L --> P{Ping Latency}
    P -->|< 30ms| Q[Network: Strong üü¢]
    P -->|30-60ms| R[Network: Good üü°]
    P -->|> 60ms| S[Network: Weak üî¥]
    P -->|-1| T[Network: No Ping üî¥]
    
    Q --> U{Throughput Check}
    R --> U
    S --> U
    T --> U
    
    U -->|> 100 Mbps Down| V[Speed: Excellent üü¢]
    U -->|50-100 Mbps Down| W[Speed: Good üü°]
    U -->|< 50 Mbps Down| X[Speed: Limited üî¥]
    
    V --> Y[Check Additional Metrics]
    W --> Y
    X --> Y
    
    Y --> Z{GPS Status}
    Z -->|Valid + > 10 sats| AA[GPS: Strong üü¢]
    Z -->|Valid + 5-10 sats| BB[GPS: Moderate üü°]
    Z -->|Invalid or < 5 sats| CC[GPS: Weak üî¥]
    
    AA --> DD{Obstruction Check}
    BB --> DD
    CC --> DD
    
    DD -->|< 2%| EE[Sky View: Clear üü¢]
    DD -->|2-10%| FF[Sky View: Partially Blocked üü°]
    DD -->|> 10%| GG[Sky View: Obstructed üî¥]
    
    EE --> HH[Display Status & Metrics]
    FF --> HH
    GG --> HH
    M --> HH
    N --> HH
    O --> HH
    
    HH --> II{State Change?}
    II -->|Yes| JJ[Send Notification<br/>Log Change Event]
    II -->|No| KK[Update Display Only]
    
    JJ --> LL[Wait 5 seconds]
    KK --> LL
    LL --> B
    
    style A fill:#e1f5fe
    style H fill:#c8e6c9
    style I fill:#fff3e0
    style J fill:#ffebee
    style K fill:#ffebee
    style E fill:#ffebee
    style Q fill:#c8e6c9
    style R fill:#fff3e0
    style S fill:#ffebee
    style T fill:#ffebee
#+end_src

* Bash Monitoring Script

This script implements the monitoring flow above and prints changes when they happen:

#+begin_src bash :tangle starlink_monitor.sh :shebang "#!/bin/bash"
#!/bin/bash

# Starlink Status Monitor
# Monitors Starlink connection and reports status changes

# Configuration
STARLINK_IP="192.168.100.1"
STARLINK_PORT="9200"
CHECK_INTERVAL=5
LOG_FILE="/tmp/starlink_monitor.log"

# State tracking
PREVIOUS_STATE=""
PREVIOUS_PING_QUALITY=""
PREVIOUS_SPEED_QUALITY=""
PREVIOUS_GPS_QUALITY=""
PREVIOUS_OBSTRUCTION_QUALITY=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log_event() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Check if grpcurl is available
check_dependencies() {
    if ! command -v grpcurl &> /dev/null; then
        echo -e "${RED}‚ùå grpcurl is not installed. Please install it with: brew install grpcurl${NC}"
        exit 1
    fi
    
    if ! command -v jq &> /dev/null; then
        echo -e "${RED}‚ùå jq is not installed. Please install it with: brew install jq${NC}"
        exit 1
    fi
}

# Query Starlink API
query_starlink() {
    timeout 10 grpcurl -plaintext -d '{"get_status":{}}' "$STARLINK_IP:$STARLINK_PORT" SpaceX.API.Device.Device/Handle 2>/dev/null
}

# Determine connection status
get_connection_status() {
    local json="$1"
    
    # Check if there's an outage
    local outage_cause
    outage_cause=$(echo "$json" | jq -r '.dishGetStatus.outage.cause // empty')
    
    if [ -n "$outage_cause" ]; then
        case "$outage_cause" in
            "BOOTING")
                echo "BOOTING"
                ;;
            "NO_PINGS")
                echo "NETWORK_ISSUES"
                ;;
            *)
                echo "SERVICE_ISSUE"
                ;;
        esac
    else
        echo "ONLINE"
    fi
}

# Get ping quality
get_ping_quality() {
    local json="$1"
    local latency
    latency=$(echo "$json" | jq -r '.dishGetStatus.popPingLatencyMs // -1')
    
    if [ "$latency" = "-1" ] || [ "$latency" = "null" ]; then
        echo "NO_PING"
    elif [ "$(echo "$latency < 30" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
        echo "STRONG"
    elif [ "$(echo "$latency < 60" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
        echo "GOOD"
    else
        echo "WEAK"
    fi
}

# Get speed quality
get_speed_quality() {
    local json="$1"
    local down_bps up_bps down_mbps
    down_bps=$(echo "$json" | jq -r '.dishGetStatus.downlinkThroughputBps // 0')
    down_mbps=$(echo "scale=1; $down_bps / 1000000" | bc -l 2>/dev/null || echo "0")
    
    if [ "$(echo "$down_mbps > 100" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
        echo "EXCELLENT"
    elif [ "$(echo "$down_mbps > 50" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
        echo "GOOD"
    else
        echo "LIMITED"
    fi
}

# Get GPS quality
get_gps_quality() {
    local json="$1"
    local gps_valid gps_sats
    gps_valid=$(echo "$json" | jq -r '.dishGetStatus.gpsStats.gpsValid // false')
    gps_sats=$(echo "$json" | jq -r '.dishGetStatus.gpsStats.gpsSats // 0')
    
    if [ "$gps_valid" = "true" ] && [ "$gps_sats" -gt 10 ]; then
        echo "STRONG"
    elif [ "$gps_valid" = "true" ] && [ "$gps_sats" -ge 5 ]; then
        echo "MODERATE"
    else
        echo "WEAK"
    fi
}

# Get obstruction quality
get_obstruction_quality() {
    local json="$1"
    local fraction
    fraction=$(echo "$json" | jq -r '.dishGetStatus.obstructionStats.fractionObstructed // 0')
    local percentage
    percentage=$(echo "scale=1; $fraction * 100" | bc -l 2>/dev/null || echo "0")
    
    if [ "$(echo "$percentage < 2" | bc -l 2>/dev/null || echo 1)" -eq 1 ]; then
        echo "CLEAR"
    elif [ "$(echo "$percentage < 10" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
        echo "PARTIALLY_BLOCKED"
    else
        echo "OBSTRUCTED"
    fi
}

# Format status with emoji and color
format_status() {
    local status="$1"
    case "$status" in
        "ONLINE")
            echo -e "${GREEN}üõ∞Ô∏è  ONLINE${NC}"
            ;;
        "BOOTING")
            echo -e "${YELLOW}üîÑ BOOTING${NC}"
            ;;
        "NETWORK_ISSUES")
            echo -e "${RED}üì° NETWORK ISSUES${NC}"
            ;;
        "SERVICE_ISSUE")
            echo -e "${RED}‚ö†Ô∏è  SERVICE ISSUE${NC}"
            ;;
        "ERROR")
            echo -e "${RED}‚ùå CONNECTION ERROR${NC}"
            ;;
    esac
}

# Format quality indicators
format_quality() {
    local type="$1"
    local quality="$2"
    local value="$3"
    
    case "$quality" in
        "STRONG"|"EXCELLENT"|"CLEAR")
            echo -e "${GREEN}üü¢ $type: $value${NC}"
            ;;
        "GOOD"|"MODERATE"|"PARTIALLY_BLOCKED")
            echo -e "${YELLOW}üü° $type: $value${NC}"
            ;;
        *)
            echo -e "${RED}üî¥ $type: $value${NC}"
            ;;
    esac
}

# Main monitoring function
monitor_starlink() {
    local json response status ping_quality speed_quality gps_quality obstruction_quality
    local changed=false
    
    # Query the API
    response=$(query_starlink)
    
    if [ $? -eq 0 ] && [ -n "$response" ]; then
        json="$response"
        status=$(get_connection_status "$json")
        ping_quality=$(get_ping_quality "$json")
        speed_quality=$(get_speed_quality "$json")
        gps_quality=$(get_gps_quality "$json")
        obstruction_quality=$(get_obstruction_quality "$json")
    else
        status="ERROR"
        ping_quality="NO_PING"
        speed_quality="LIMITED"
        gps_quality="WEAK"
        obstruction_quality="UNKNOWN"
    fi
    
    # Check for changes
    if [ "$status" != "$PREVIOUS_STATE" ]; then
        log_event "Status changed: $(format_status "$PREVIOUS_STATE") ‚Üí $(format_status "$status")"
        changed=true
    fi
    
    if [ "$ping_quality" != "$PREVIOUS_PING_QUALITY" ]; then
        local latency
        if [ "$status" != "ERROR" ]; then
            latency=$(echo "$json" | jq -r '.dishGetStatus.popPingLatencyMs // "N/A"')
            log_event "$(format_quality "Network" "$ping_quality" "${latency}ms")"
        fi
        changed=true
    fi
    
    if [ "$speed_quality" != "$PREVIOUS_SPEED_QUALITY" ]; then
        if [ "$status" != "ERROR" ]; then
            local down_bps up_bps down_mbps up_mbps
            down_bps=$(echo "$json" | jq -r '.dishGetStatus.downlinkThroughputBps // 0')
            up_bps=$(echo "$json" | jq -r '.dishGetStatus.uplinkThroughputBps // 0')
            down_mbps=$(echo "scale=1; $down_bps / 1000000" | bc -l 2>/dev/null || echo "0")
            up_mbps=$(echo "scale=1; $up_bps / 1000000" | bc -l 2>/dev/null || echo "0")
            log_event "$(format_quality "Speed" "$speed_quality" "‚Üì${down_mbps} ‚Üë${up_mbps} Mbps")"
        fi
        changed=true
    fi
    
    if [ "$gps_quality" != "$PREVIOUS_GPS_QUALITY" ]; then
        if [ "$status" != "ERROR" ]; then
            local gps_sats
            gps_sats=$(echo "$json" | jq -r '.dishGetStatus.gpsStats.gpsSats // 0')
            log_event "$(format_quality "GPS" "$gps_quality" "${gps_sats} satellites")"
        fi
        changed=true
    fi
    
    if [ "$obstruction_quality" != "$PREVIOUS_OBSTRUCTION_QUALITY" ]; then
        if [ "$status" != "ERROR" ]; then
            local fraction percentage
            fraction=$(echo "$json" | jq -r '.dishGetStatus.obstructionStats.fractionObstructed // 0')
            percentage=$(echo "scale=1; $fraction * 100" | bc -l 2>/dev/null || echo "0")
            log_event "$(format_quality "Sky View" "$obstruction_quality" "${percentage}% obstructed")"
        fi
        changed=true
    fi
    
    # Update previous states
    PREVIOUS_STATE="$status"
    PREVIOUS_PING_QUALITY="$ping_quality"
    PREVIOUS_SPEED_QUALITY="$speed_quality"
    PREVIOUS_GPS_QUALITY="$gps_quality"
    PREVIOUS_OBSTRUCTION_QUALITY="$obstruction_quality"
    
    # Show current summary if there were changes
    if [ "$changed" = true ]; then
        echo -e "\n${BLUE}üìä Current Status Summary:${NC}"
        format_status "$status"
        if [ "$status" != "ERROR" ]; then
            local latency down_bps up_bps down_mbps up_mbps gps_sats fraction percentage
            latency=$(echo "$json" | jq -r '.dishGetStatus.popPingLatencyMs // "N/A"')
            down_bps=$(echo "$json" | jq -r '.dishGetStatus.downlinkThroughputBps // 0')
            up_bps=$(echo "$json" | jq -r '.dishGetStatus.uplinkThroughputBps // 0')
            down_mbps=$(echo "scale=1; $down_bps / 1000000" | bc -l 2>/dev/null || echo "0")
            up_mbps=$(echo "scale=1; $up_bps / 1000000" | bc -l 2>/dev/null || echo "0")
            gps_sats=$(echo "$json" | jq -r '.dishGetStatus.gpsStats.gpsSats // 0')
            fraction=$(echo "$json" | jq -r '.dishGetStatus.obstructionStats.fractionObstructed // 0')
            percentage=$(echo "scale=1; $fraction * 100" | bc -l 2>/dev/null || echo "0")
            
            format_quality "Network" "$ping_quality" "${latency}ms"
            format_quality "Speed" "$speed_quality" "‚Üì${down_mbps} ‚Üë${up_mbps} Mbps"
            format_quality "GPS" "$gps_quality" "${gps_sats} satellites"
            format_quality "Sky View" "$obstruction_quality" "${percentage}% obstructed"
        fi
        echo ""
    fi
}

# Signal handlers for clean shutdown
cleanup() {
    log_event "Monitoring stopped by user"
    exit 0
}

trap cleanup SIGINT SIGTERM

# Main execution
main() {
    echo -e "${BLUE}üõ∞Ô∏è  Starlink Status Monitor${NC}"
    echo "Monitoring Starlink at $STARLINK_IP:$STARLINK_PORT"
    echo "Log file: $LOG_FILE"
    echo "Press Ctrl+C to stop"
    echo ""
    
    check_dependencies
    log_event "Starlink monitoring started"
    
    while true; do
        monitor_starlink
        sleep "$CHECK_INTERVAL"
    done
}

# Run the monitor
main "$@"
#+end_src


* References
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
# End:
