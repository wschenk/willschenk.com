<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Will Schenk</title>
  <subtitle>Lets build things</subtitle>
  <id>http://willschenk.com/</id>
  <link href="http://willschenk.com/"/>
  <link href="http://willschenk.com/feed.xml" rel="self"/>
  <updated>2014-11-28T15:02:46-05:00</updated>
  <author>
    <name>Will Schenk</name>
  </author>
  <entry>
    <title>New HappySeed released</title>
    <link rel="alternate" href="http://willschenk.com/new-happyseed-released/"/>
    <id>http://willschenk.com/new-happyseed-released/</id>
    <published>2014-11-28T14:05:00-05:00</published>
    <updated>2014-11-28T14:05:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;h2&gt;Make apps faster.&lt;/h2&gt;

&lt;p&gt;Head on over to the &lt;a href="http://seed.happyfuncorp.com"&gt;HappySeed website&lt;/a&gt; to get the latest version of HappyFunCorp&amp;#39;s starter application toolkit.&lt;/p&gt;

&lt;p&gt;HappySeed is a set of application templates to help you get started building out new sites. The main section is a rails application template plus a set of rails generators to help you get started with rails appliations quickly. These generators setup the configuration of the application in a standard way, and the full set of generators include many things for setting up a modern rails app and well as middleman apps.&lt;/p&gt;

&lt;p&gt;You can update your command line tools by doing&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gem install happy_seed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then create rails apps, plugins, engines, and middleman static sites using the new &lt;code&gt;happy_seed&lt;/code&gt; tool.&lt;/p&gt;

&lt;h2&gt;Rails sites&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed rails app_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/rails.html"&gt;Read rails documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Rails Plugins&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed plugin plugin_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/plugin.html"&gt;Read plug-in documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Rails Engines&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed engine engine_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/plugin.html"&gt;Read engine documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Middleman Static Sites&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed static static_site
[...]
$ happy_seed static_blog static_site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/middleman.html"&gt;Read static documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Get that code!&lt;/h2&gt;

&lt;p&gt;Head on over to &lt;a href="https://github.com/HappyFunCorp/happy_seed"&gt;github&lt;/a&gt; to check it out!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Image Credit: &lt;a href="http://consciouslifenews.com"&gt;consciouslife news&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Building Sites with Middleman</title>
    <link rel="alternate" href="http://willschenk.com/building-sites-with-middleman/"/>
    <id>http://willschenk.com/building-sites-with-middleman/</id>
    <published>2014-11-24T19:00:00-05:00</published>
    <updated>2014-11-24T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;I make a lot of websites, and I have a certain toolkit that I use to build them.  The most useful things I use are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;layouts and partials so I only need to set things up once&lt;/li&gt;
&lt;li&gt;&lt;code&gt;haml&lt;/code&gt; for writing html, since I don&amp;#39;t like closing tags&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt; and &lt;code&gt;sass&lt;/code&gt; for writing css&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Markdown&lt;/code&gt; for formatting large blogs of content&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coffeescript&lt;/code&gt; for JavaScript&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Middleman is a static site generator, which means that it takes a bunch of source files, does some stuff with it, and produces static HTML, CSS, Images, and Javascript that can be hosted on a basic server somewhere, including &lt;a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html"&gt;hosting on S3&lt;/a&gt; or &lt;a href="https://pages.github.com"&gt;Github Pages&lt;/a&gt; so you don&amp;#39;t need to consider a server.&lt;/p&gt;

&lt;p&gt;Middleman is written in Ruby, so it&amp;#39;s our familiar toolset, and unlike &lt;a href="http://jekyllrb.com"&gt;Jekyll&lt;/a&gt; it uses &lt;a href="https://github.com/sstephenson/sprockets"&gt;Sprockets&lt;/a&gt;, which is the same asset pipelining system that Rails uses.  So you get all the benefits of using a robust system that works for Rails apps without having to learn a bunch more things.&lt;/p&gt;

&lt;p&gt;In the node world &lt;a href="http://yeoman.io"&gt;Yeoman&lt;/a&gt; does something similar, but I personally have had poor luck getting &lt;a href="http://gruntjs.com"&gt;Grunt&lt;/a&gt; to work reliably in practice.&lt;/p&gt;

&lt;h2&gt;Setting up a simple static site with Middleman&lt;/h2&gt;

&lt;p&gt;One of the problems with starting with Middleman is that there are so many places to start.  Lets look at how to setup a basic middleman site with bootstrap-sass, haml, and bower.  First thing is to install middleman:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gem install middleman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And create an app:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ middleman new static_site
[...]
      create  static_site/.gitignore
      create  static_site/config.rb
      create  static_site/source/index.html.erb
      create  static_site/source/layouts/layout.erb
      create  static_site/source/stylesheets
      create  static_site/source/stylesheets/all.css
      create  static_site/source/stylesheets/normalize.css
      create  static_site/source/javascripts
      create  static_site/source/javascripts/all.js
      create  static_site/source/images
      create  static_site/source/images/background.png
      create  static_site/source/images/middleman.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates 4 files in the main directory, &lt;code&gt;Gemfile&lt;/code&gt; and &lt;code&gt;Gemfile.lock&lt;/code&gt;, which we know and love, &lt;code&gt;config.rb&lt;/code&gt; which configures how middleman generates the site, and &lt;code&gt;source&lt;/code&gt; which are the sourcefiles of the site.&lt;/p&gt;

&lt;h2&gt;Gemfile&lt;/h2&gt;

&lt;p&gt;By default, &lt;code&gt;middleman&lt;/code&gt; installs the &lt;code&gt;middleman-livereload&lt;/code&gt; plugin, so in development mode any browers that have a page open with refresh when you save a file.  This makes testing a lot easier.  We can install other gems here to add different functionality.  Let&amp;#39;s add a few of these now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;quot;middleman-deploy&amp;quot;
gem &amp;#39;middleman-bootstrap-navbar&amp;#39;
gem &amp;quot;bootstrap-sass&amp;quot;
gem &amp;quot;jquery-middleman&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first two gems expand the functionality of middleman, one to add tasks to push the final site build to &lt;code&gt;s3&lt;/code&gt;, &lt;code&gt;gh-pages&lt;/code&gt; and a whole bunch more, and the second to make it easier to build &lt;code&gt;bootstrap&lt;/code&gt; navbars.&lt;/p&gt;

&lt;p&gt;The file two are including &lt;code&gt;bootstrap-sass&lt;/code&gt; -- the same that we use for rails sites -- and &lt;code&gt;jquery&lt;/code&gt;.  These get included into the sprockets asset path, so you don&amp;#39;t need to maintain them in your project.  (We&amp;#39;ll also see below how to integrate &lt;code&gt;bower&lt;/code&gt; components into your project.)&lt;/p&gt;

&lt;h2&gt;Tweaking Middleman: &lt;code&gt;config.rb&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This is where we configure how middleman itself works.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# For custom domains on github pages
page &amp;quot;CNAME&amp;quot;, layout: false

set :css_dir, &amp;#39;stylesheets&amp;#39;
set :js_dir, &amp;#39;javascripts&amp;#39;
set :images_dir, &amp;#39;images&amp;#39;

# Better markdown support
# set :markdown, :tables =&amp;gt; true, :autolink =&amp;gt; true, :gh_blockcode =&amp;gt; true, :fenced_code_blocks =&amp;gt; true
# set :markdown_engine, :redcarpet

# Turn this on if you want to make your url&amp;#39;s prettier, without the .html
activate :directory_indexes

# Automatic image dimensions on image_tag helper
# activate :automatic_image_sizes

# Easier bootstrap navbars
activate :bootstrap_navbar

configure :development do
  activate :livereload
end

# Build-specific configuration
configure :build do
  # Any files you want to ignore:
  ignore &amp;#39;/admin/*&amp;#39;

  # For example, change the Compass output style for deployment
  activate :minify_css

  # Minify Javascript on build
  activate :minify_javascript

  # Enable cache buster
  activate :asset_hash

  # Use relative URLs
  activate :relative_assets
end


# This will push to the gh-pages branch of the repo, which will
# host it on github pages (If this is a github repository)
activate :deploy do |deploy|
  deploy.method = :git
  deploy.build_before = true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets go through this in detail.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;page &amp;quot;CNAME&amp;quot;, layout: false&lt;/code&gt;  says to move the file called &lt;code&gt;CNAME&lt;/code&gt; over without wrapping in the main layout.  Since this file doesn&amp;#39;t have .html in the name, it would otherwise get ignored.  This file is for having a custom domain on Github Pages, if that&amp;#39;s the sort of thing you are in to.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;set&lt;/code&gt; commands are there to configure different middleman settings, here to show where the various stylesheet, image, and css directories are.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;activate :directory_indexes&lt;/code&gt; with enable &lt;em&gt;pretty urls&lt;/em&gt;.  Directory indexes means that files named &lt;code&gt;about.html&lt;/code&gt; will actually get generated into a file called &lt;code&gt;/about/index.html&lt;/code&gt;, and will rely on the underlying server to have &lt;code&gt;/about&lt;/code&gt; actually show the directory &amp;quot;index&amp;quot; page, making the urls prettier.  This doesn&amp;#39;t work on all servers but works on most of them.  This plugin will actually rewrite the output of the &lt;code&gt;link_to&lt;/code&gt; tags, so you don&amp;#39;t need to adjust your templates to work.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;activate :bootstrap_navbar&lt;/code&gt; is an extension that we added in the Gemfile, which makes it easier to generate bootstrap navbars.  Extensions generally work in three ways: they add helper methods, they change the way that the sitemap is processed, or they add different commands to the &amp;quot;middleman&amp;quot; command.&lt;/p&gt;

&lt;p&gt;We see an example of that at the bottom of the &lt;code&gt;config.rb&lt;/code&gt; file, where we configure the &lt;code&gt;deploy&lt;/code&gt; extension:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;activate :deploy do |deploy|
  deploy.method = :git
  deploy.build_before = true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also takes some configuration, and in this case it set to deploy to github pages, and to make sure that it generates the site before doing so.  Here is the &lt;a href="https://github.com/karlfreeman/middleman-deploy"&gt;middleman-deploy&lt;/a&gt; github page with documentation.&lt;/p&gt;

&lt;p&gt;There are two sections that each configure a different middleman environment.  The first is used when you run &lt;code&gt;middleman server&lt;/code&gt; to look at the site locally:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;configure :development do
  activate :livereload
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final section is configuring the &lt;code&gt;build&lt;/code&gt; process, when you run &lt;code&gt;middleman build&lt;/code&gt; and it creates the generated files in the &lt;code&gt;build&lt;/code&gt; directory.  The entry below ignores certain files for the build, and runs minifiers over the css and javascript, and turns on &lt;em&gt;cache busting&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Build-specific configuration
configure :build do
  # Any files you want to ignore:
  ignore &amp;#39;/admin/*&amp;#39;

  # For example, change the Compass output style for deployment
  activate :minify_css

  # Minify Javascript on build
  activate :minify_javascript

  # Enable cache buster
  activate :asset_hash

  # Use relative URLs
  activate :relative_assets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Using bower&lt;/h2&gt;

&lt;p&gt;The basic way to use bower is to put this in &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;sprockets.append_path File.join root, &amp;#39;bower_components&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then you can put things in your &lt;code&gt;all.js&lt;/code&gt; file like&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//= require &amp;#39;component&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get all of the assets that are included in the packge, you may need to specify the package in the &lt;code&gt;config.rb&lt;/code&gt; file, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;sprockets.import_asset &amp;#39;jquery&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information on the &lt;a href="http://middlemanapp.com/basics/asset-pipeline/"&gt;Middleman Asset Pipline documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Using layouts and partials&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;source&lt;/code&gt; directory is where the actual code for your site lives.  Here is an example &lt;code&gt;layouts/layout.haml&lt;/code&gt; file to give you a sense of how to use layouts and include partials:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;!!! 5
%html.no-js.sticky
  %head
    %meta{ :charset =&amp;gt; &amp;#39;utf-8&amp;#39; }/
    %meta{ &amp;#39;http-equiv&amp;#39; =&amp;gt; &amp;#39;X-UA-Compatible&amp;#39;, :content =&amp;gt; &amp;#39;IE=edge,chrome=1&amp;#39; }/

    %title This site is amazing!

    %meta{ :name =&amp;gt; &amp;#39;description&amp;#39;, :content =&amp;gt; &amp;#39;&amp;#39; }/
    %meta{ :name =&amp;gt; &amp;#39;viewport&amp;#39;, :content =&amp;gt; &amp;#39;width=device-width&amp;#39; }/
    = stylesheet_link_tag &amp;#39;application&amp;#39;, &amp;quot;socicons&amp;quot;, &amp;quot;animate&amp;quot;

  %body
    = partial &amp;quot;layouts/main_header&amp;quot;

    ~ yield

    = partial &amp;quot;layouts/footer&amp;quot;
    = partial &amp;quot;layouts/javascripts&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this usage, this is similar to the way that rails layouts work.  I&amp;#39;m using the &lt;code&gt;~&lt;/code&gt; HAML operator inside of &lt;code&gt;=&lt;/code&gt; here because I want to make sure that it doesn&amp;#39;t do anything wonky with the indention on &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; blocks, btw.&lt;/p&gt;

&lt;p&gt;Middleman has a concept of nested layouts, which lets you have wrap an a layout around another one.  I think that this is confusing in practice, but as an example you could have a &lt;code&gt;layouts/sidebar_layout.erb&lt;/code&gt; that looked like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;% wrap_layout :layout do %&amp;gt;
    &amp;lt;div class=&amp;quot;sidebar&amp;quot;&amp;gt;
        &amp;lt;%= partial &amp;quot;layouts/sidebar&amp;quot; %&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
        &amp;lt;%= yield %&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;The YAML preable, the preyaml?&lt;/h2&gt;

&lt;p&gt;Metadata about the template is included in a block of text at the top of the file, which gets pulled off to set things that the templating system can use later.  On the top of this file that I am editing right now, it looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;#39;Building Sites with Middleman&amp;#39;
subtitle: &amp;#39;lean publishing&amp;#39;
tags: middleman, ruby, howto
header_image: books.jpg
---

I make a lot of websites, and I have a certain toolkit that I use to build... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;subtitle&lt;/code&gt;, &lt;code&gt;tags&lt;/code&gt; and &lt;code&gt;header_image&lt;/code&gt; attributues are available in the templates as page data, so you can access them like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;  %h1= current_article.title
  %h2= current_article.data[&amp;#39;subtitle&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;title&lt;/em&gt; is built into middleman, &lt;em&gt;subtitle&lt;/em&gt; and &lt;em&gt;header image&lt;/em&gt; are just some random things I made up.  The &lt;code&gt;tags&lt;/code&gt; attribute is part of the &lt;code&gt;middleman-blog&lt;/code&gt; extension which we will cover below.&lt;/p&gt;

&lt;h2&gt;How the build works&lt;/h2&gt;

&lt;p&gt;When you run &lt;code&gt;middleman server&lt;/code&gt; or &lt;code&gt;middleman build&lt;/code&gt;, middleman loads up the configuration file in &lt;code&gt;config.rb&lt;/code&gt;.  It creates a sitemap based upon the files in the &lt;code&gt;source&lt;/code&gt; directory as well as other directives inside of the config.rb file. &lt;/p&gt;

&lt;p&gt;By default it only includes files like &lt;code&gt;.html.erb&lt;/code&gt; and &lt;code&gt;.js&lt;/code&gt;, but you can set it manually include a non-template file (like our &lt;code&gt;page &amp;quot;CNAME&amp;quot;&lt;/code&gt; above or create other &lt;code&gt;proxy&lt;/code&gt; files.  Proxy files are a way of seperating out the templates from the source data.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Assumes the file source/about/template.html.erb exists
[&amp;quot;tom&amp;quot;, &amp;quot;dick&amp;quot;, &amp;quot;harry&amp;quot;].each do |name|
  proxy &amp;quot;/about/#{name}.html&amp;quot;, &amp;quot;/about/template.html&amp;quot;, :locals =&amp;gt; { :person_name =&amp;gt; name }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates three entries into the sitemap called &lt;code&gt;/about/tom.html&lt;/code&gt;, &lt;code&gt;/about/dick.html&lt;/code&gt; and &lt;code&gt;/about/harry.html&lt;/code&gt; that use a specific template.&lt;/p&gt;

&lt;p&gt;This data doesn&amp;#39;t need to be hardcoded into the &lt;code&gt;config.rb&lt;/code&gt; btw, you can also place &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;yml&lt;/code&gt; files in the &lt;code&gt;data/&lt;/code&gt; directory which middleman will load automatically.  For example, &lt;code&gt;data/employees.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;[{&amp;quot;name&amp;quot;:&amp;quot;Tom&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Janitor&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;Mary&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;CEO&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then in your &lt;code&gt;config.rb&lt;/code&gt; you could access this as:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;data[&amp;#39;employees&amp;#39;].each do |employee|
  proxy &amp;quot;/about/#{name}.html&amp;quot;, &amp;quot;/about/template.html&amp;quot;, :locals =&amp;gt; { :person_name =&amp;gt; employee[:name], :title =&amp;gt; employee[:title] }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then each entry in the sitemap the file is processed (based upon the extension, so scss -&amp;gt; js, haml -&amp;gt; html, etc.) into the build directory.  Helper methods are available inside of the templates for things like &lt;code&gt;javascript_include_tag&lt;/code&gt;, &lt;code&gt;stylesheet_link_tag&lt;/code&gt;, &lt;code&gt;link_to&lt;/code&gt; and &lt;code&gt;image_tag&lt;/code&gt; and all of the rest.&lt;/p&gt;

&lt;h2&gt;The preview: &lt;code&gt;middleman server&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Starting the server in preview mode will start a local server on port &lt;code&gt;4567&lt;/code&gt; that generates the files on demand.  If you have livereload enabled this will automatically trigger a page refresh for any open browsers, so you can tweak and look at things as you go.&lt;/p&gt;

&lt;p&gt;Inside of your templates, &lt;code&gt;config.environment == :development&lt;/code&gt; when you are in preview mode.  So, if there are some things that you don&amp;#39;t want to push to the live site but are useful for development, you can switch them on and off using that mechanism.&lt;/p&gt;

&lt;h2&gt;The build: &lt;code&gt;middleman build&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This does basically the same thing as the server, but the templates are generally further processed.  Cachebusting can be enabled, and you can include tracking code if &lt;code&gt;config.environment == :build&lt;/code&gt; is true.  This goes through all of the files in source that look like webfiles and places them in the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;And easy way to check out what you have there is by &lt;code&gt;cd&lt;/code&gt;ing into the &lt;code&gt;build/&lt;/code&gt; directory and running a simple webserver to serve the pages.  Relative links don&amp;#39;t work when you open the file directly in the browser, so you need to use an actual webserver.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ cd build
$ python -m SimpleHTTPServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then open a new browser on port &lt;code&gt;8000&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;The deploy: &lt;code&gt;middleman deploy&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;In the basic &lt;code&gt;:git&lt;/code&gt; setting that we have above, middleman deploy will build the site into the &lt;code&gt;build/&lt;/code&gt; directory, switch that directory to the &lt;code&gt;gh-pages&lt;/code&gt; branch, and push it to &lt;code&gt;origin&lt;/code&gt;.  Assuming that you are hosting your repo on github, this will publish the static content on github pages.&lt;/p&gt;

&lt;p&gt;If you want to use a &lt;a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/"&gt;custom domain&lt;/a&gt; then you need to create a &lt;code&gt;CNAME&lt;/code&gt; file in &lt;code&gt;source/&lt;/code&gt; with the domain name, and set up your DNS records to match.&lt;/p&gt;

&lt;p&gt;One thing to note is that while changes to the pages seem to deploy quickly, it takes a long time for the first push to github pages to show up, on the order of 10-15 minutes.&lt;/p&gt;

&lt;p&gt;More information on &lt;a href="https://github.com/karlfreeman/middleman-deploy"&gt;middleman-deploy&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Building a blog&lt;/h2&gt;

&lt;p&gt;There are two good extensions for building a blog with middleman.  The default template for blog is sort of confusing in the way that it&amp;#39;s laid out, mainly because it gets rid of the &lt;code&gt;layouts/&lt;/code&gt; directory, but let&amp;#39;s go through it and see how it&amp;#39;s supposed to work:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gem install middleman-blog
$ middleman new static_blog --template=blog
      create  static_blog/.gitignore
      create  static_blog/config.rb
      create  static_blog/source
      create  static_blog/source/2012-01-01-example-article.html.markdown
      create  static_blog/source/calendar.html.erb
      create  static_blog/source/feed.xml.builder
      create  static_blog/source/index.html.erb
      create  static_blog/source/layout.erb
      create  static_blog/source/tag.html.erb
      create  static_blog/source/stylesheets
      create  static_blog/source/javascripts
      create  static_blog/source/images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have another middleman site, with a bunch of files.  It also creates a new command:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ middleman article &amp;quot;This is the title of my article&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s also include the &lt;code&gt;middleman-blog-drafts&lt;/code&gt; gem into the &lt;code&gt;Gemfile&lt;/code&gt;, &lt;code&gt;activate :drafts&lt;/code&gt; in `config.rb, and that will give us a few more commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ middleman draft &amp;quot;This is amazing&amp;quot;
      create  source/drafts/this-is-amazing.html.markdown
$ middleman publish source/drafts/this-is-amazing.html.markdown
      create  source/2014-11-25-this-is-amazing.html.markdown
      remove  source/drafts/this-is-amazing.html.markdown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This lets us keep drafts in git and doesn&amp;#39;t force us to commit to a date until we are ready to publish it.  There are &lt;code&gt;published&lt;/code&gt; and &lt;code&gt;date&lt;/code&gt; attributes that the default blog extension knows about to turn it on and off, and is a good example of something that you can see in development but not production, but that still leaves to moving files around manually to adjust the date.&lt;/p&gt;

&lt;h2&gt;What does it add?&lt;/h2&gt;

&lt;p&gt;In addition to the sitemap, we now have a &lt;code&gt;blog&lt;/code&gt;, &lt;code&gt;article&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt; concept inside of the middleman app.  Articles are represented as pages (by default using &lt;code&gt;markdown&lt;/code&gt;) but the &lt;code&gt;tag&lt;/code&gt; and &lt;code&gt;calendar&lt;/code&gt; templates are actually more like &lt;code&gt;proxy&lt;/code&gt; templates than file templates, and when the site is generated middleman will iterate over then to produce many output files from one template.&lt;/p&gt;

&lt;p&gt;Part of the &lt;code&gt;index.html.haml&lt;/code&gt; of this site looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;  - (drafts + page_articles).each do |article|
    .post
      .post-date
        - unless article.is_a? ::Middleman::Blog::Drafts::DraftArticle
          %p= article.date.strftime( &amp;#39;%b %e&amp;#39; )
        - else
          %p.draft Draft
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;m putting all of the articles in a list, both drafts and published ones, and only showing the date for articles which have already been published.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s what gets added to the &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;activate :blog do |blog|
  # This will add a prefix to all links, template references and source paths
  # blog.prefix = &amp;quot;blog&amp;quot;

  # blog.permalink = &amp;quot;{year}/{month}/{day}/{title}.html&amp;quot;
  # Matcher for blog source files
  # blog.sources = &amp;quot;{year}-{month}-{day}-{title}.html&amp;quot;
  # blog.taglink = &amp;quot;tags/{tag}.html&amp;quot;
  # blog.layout = &amp;quot;layout&amp;quot;
  # blog.summary_separator = /()/
  # blog.summary_length = 250
  # blog.year_link = &amp;quot;{year}.html&amp;quot;
  # blog.month_link = &amp;quot;{year}/{month}.html&amp;quot;
  # blog.day_link = &amp;quot;{year}/{month}/{day}.html&amp;quot;
  # blog.default_extension = &amp;quot;.markdown&amp;quot;

  blog.tag_template = &amp;quot;tag.html&amp;quot;
  blog.calendar_template = &amp;quot;calendar.html&amp;quot;

  # Enable pagination
  # blog.paginate = true
  # blog.per_page = 10
  # blog.page_link = &amp;quot;page/{num}&amp;quot;
end

activate :drafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should be enough to get you started, and more &lt;a href="http://middlemanapp.com/basics/blogging/"&gt;documentation is here&lt;/a&gt; .  At this point it really becomes a design and development challenge, not figuring out how to use the tool.&lt;/p&gt;

&lt;h2&gt;That&amp;#39;s the basics.&lt;/h2&gt;

&lt;p&gt;Middleman gives you all of the front-end developer benefits of using a system like Rails, but outputs static content than can be served anywhere without any dependancies.  Many sites don&amp;#39;t really require all that for them to run, and it&amp;#39;s crazy to me that something as read heavy as a blog often can&amp;#39;t perform well under load given that it&amp;#39;s just serving up the same old stuff over and over again.  You want to have some tooling to make it easier, but it doesn&amp;#39;t need to be &lt;em&gt;run time&lt;/em&gt; tooling.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Image Credit: &lt;a href="https://www.flickr.com/photos/aigle_dore/6365101775/in/photolist-aGsP14-7PozJp-84P71r-dphot9-5qz3ks-eqHuv-6NP8d6-HdurS-aibaen-ix8Rbz-6buevW-7acJMF-8DFBf3-MLnGM-dGa2xi-f4HeM7-zXqL6-88og6h-r7w3U-2qKgwi-mcp7h-4eXcGM-9uv3gC-7BAEiV-5RzRtp-7JKRHh-6iUdMZ-2bUDT-8s4PDi-8pvSWc-dynb6k-zV2x5-4xWMzG-dsxGqc-7Cby3b-9t3zWm-b4jsc2-8YyqSQ-9ggca5-aGsPSg-68SVDi-4PNHrt-7JGpz4-aL22G2-q1ic-sZMVW-84NAEC-8JBSSW-9k6cM-89NBaJ"&gt;Moyan Brenn&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Scripting Twitter: Collecting Data and Writing Bots</title>
    <link rel="alternate" href="http://willschenk.com/scripting-twitter/"/>
    <id>http://willschenk.com/scripting-twitter/</id>
    <published>2014-11-19T19:00:00-05:00</published>
    <updated>2014-11-19T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Lets build on our &lt;a href="http://willschenk.com/making-a-command-line-utility-with-gems-and-thor"&gt;command line url exploring tool&lt;/a&gt; to look at how we can interact with Twitter.  We are going to cover how to make a script that will pull information out of twitter, how to deal with its rate limiting, and how to interact with users on Twitter itself.&lt;/p&gt;

&lt;p&gt;Twitter uses &lt;a href="https://dev.twitter.com/oauth/overview/faq"&gt;OAuth 1.0A&lt;/a&gt; as a way to authenticate requests.  As a script writer, this is super annoying, because you can&amp;#39;t just stick a username and password in the environment and go from there.  You need to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://apps.twitter.com"&gt;Register you application with twitter&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Store the &amp;quot;client key&amp;quot; for your application.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Get a user to grant your application access to twitter, and then use that &amp;quot;authorization key&amp;quot; to access the API.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Then figure out how to use the API.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is a bit overkill for building a simple script, especially since the 3 way process of having your application request access on behalf of a specific user on the twitters servers is a pain for a command line interface.  And when you configure your application on twitter you need to specify a &amp;quot;callback URL&amp;quot;, which a) is different on development, staging and production webapp environments and b) you don&amp;#39;t have a web app.&lt;/p&gt;

&lt;p&gt;Luckily for you twitter has a work around.&lt;/p&gt;

&lt;h2&gt;Firstly, we create the Twitter App&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Go to &lt;a href="https://apps.twitter.com/app/new"&gt;Create new Twitter App&lt;/a&gt; and fill out the required fields.  Specifically, leave &lt;em&gt;callback URL&lt;/em&gt; blank for now.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select &lt;em&gt;Keys and Access Tokens&lt;/em&gt;.  On this page, create an access token for your user with the &lt;em&gt;Generate Access Token&lt;/em&gt; on the bottom of the page.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now we have four variables that our script needs to access twitter on behalf of your user.  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The consumer key represents your application.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The consumer secret represents your application&amp;#39;s &amp;quot;password&amp;quot;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The access token represents an authorization that a user has accepted.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The access token secret is there to make sure that access token is valid.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Make note of these variables.&lt;/p&gt;

&lt;h2&gt;Then, we code with the REST API&lt;/h2&gt;

&lt;p&gt;Make sure you have the twitter gem installed by typing:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gem install twitter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;re eventually going to add this code our CLI gem, and that dependency will be created by adding the line&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  spec.add_dependency &amp;#39;twitter&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, lets put this in and see what we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;thor&amp;#39;
require &amp;#39;twitter&amp;#39;
require &amp;#39;httparty&amp;#39;

TWITTER_APP_KEY=&amp;quot;rzlJXhI8...&amp;quot;
TWITTER_APP_SECRET=&amp;quot;euF5bItp9w...&amp;quot;
TWITTER_ACCESS_TOKEN=&amp;quot;17827...&amp;quot;
TWITTER_ACCESS_TOKEN_SECRET=&amp;quot;7NSX...&amp;quot;

def print_user_info( u )
  t = &amp;quot;%-20s: %s\n&amp;quot;
  printf t, &amp;quot;Screenname&amp;quot;, u.user_name
  printf t, &amp;quot;Full Name&amp;quot;, u.name
  printf t, &amp;quot;Bio&amp;quot;, u.description
  printf t, &amp;quot;Website&amp;quot;, u.website.to_s
  printf t, &amp;quot;Joined&amp;quot;, u.created_at.strftime( &amp;quot;%Y-%m-%d&amp;quot; )
  printf t, &amp;quot;Location&amp;quot;, u.location
  printf t, &amp;quot;Verified&amp;quot;, u.verified?
  printf t, &amp;quot;Tweets&amp;quot;, u.tweets_count
  printf t, &amp;quot;Followers&amp;quot;, u.followers_count
  printf t, &amp;quot;Following&amp;quot;, u.friends_count
  printf t, &amp;quot;Favorites count&amp;quot;, u.favorites_count
end

class CLI &amp;lt; Thor
  desc &amp;quot;user SCREENAME&amp;quot;, &amp;quot;Look up info for a specific user.&amp;quot;
  def user( username )
    print_user_info client.user( &amp;quot;wschenk&amp;quot; )
  end

# We will add more methods here

  private
  def client
    @client ||= Twitter::REST::Client.new do |config|
      config.consumer_key        = TWITTER_APP_KEY
      config.consumer_secret     = TWITTER_APP_SECRET
      config.access_token        = TWITTER_ACCESS_TOKEN
      config.access_token_secret = TWITTER_ACCESS_TOKEN_SECRET
    end
  end
end

# Only run if the script is called directly
if __FILE__ == $0
  CLI.start( ARGV )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby lib/socialinvestigator/client/twitter.rb wschenk
Screenname          : wschenk
Full Name           : Will Schenk
Bio                 : Co-Founder of HappyFunCorp.
Website             : http://t.co/OA0tQaQiAX
Joined              : 2006-12-22
Location            : Brooklyn NY
Verified            : false
Tweets              : 1674
Followers           : 330
Following           : 418
Favorites count     : 17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;For those keeping score at home, that&amp;#39;s 209 tweets a year.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We create a &lt;code&gt;Twitter::REST::Client&lt;/code&gt;, passing in the variables that we got when we created the twitter app.  Eventually we&amp;#39;ll out grow hardcoding them into the script, but for now replace the dummy values I have above with what you have and try it with some screen names.&lt;/p&gt;

&lt;h2&gt;Longing for &lt;code&gt;http://t.co/OA0tQaQiAX&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;If there&amp;#39;s one word that describes URL shorteners, that word is &lt;em&gt;rude&lt;/em&gt;.  This magical place where anyone can setup shop and link directly to other people now is now infested with middle men, who may indeed be useful but are even less popular than used car salesmen.  URL shorteners are services that &lt;em&gt;intermediate&lt;/em&gt; the actual destination of the link in order to better track who clicks on the link.  You create many shortened links and give them out to different people, and when the world at large clicks on one of them you know who they got it from.&lt;/p&gt;

&lt;p&gt;The easiest way to resolve the link is to make a &lt;code&gt;HEAD&lt;/code&gt; HTTP request to the shortening service and print where they redirect you to.  If there&amp;#39;s no location in the response, we&amp;#39;ll just return the url that was passed in.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;def lookup_url( url )
  return url if url.nil? || url == &amp;quot;&amp;quot;
  r = HTTParty.head url, { follow_redirects: false }
  r[&amp;#39;location&amp;#39;] || url
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and lets add a Thor command for it too, in the &lt;code&gt;CLI&lt;/code&gt; class, why not:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;lookup URL&amp;quot;, &amp;quot;Resolve a link&amp;quot;
  def lookup( url )
    puts lookup_url( url )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can see that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby twitter.rb lookup  http://t.co/OA0tQaQiAX
http://happyfuncorp.com
$ ruby twitter.rb lookup  http://happyfuncorp.com
http://happyfuncorp.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we can update the website &lt;code&gt;printf&lt;/code&gt; line to be:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  printf t, &amp;quot;Website&amp;quot;, lookup_url( u.website.to_s )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;The basics: tweets, timelines, mentions, retweets&lt;/h2&gt;

&lt;p&gt;With read access, you can pull down some basic stuff.&lt;/p&gt;

&lt;p&gt;Load the recent tweets this user has made:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;user_timeline&amp;quot;, &amp;quot;Show the authenticated user&amp;#39;s tweets&amp;quot;
  def user_timeline
    client.user_timeline.each do |tweet|
      puts &amp;quot;@#{tweet.user.user_name}:#{tweet.text}&amp;quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show the tweets of people who they are following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;home_timeline&amp;quot;, &amp;quot;Show the authenticated user&amp;#39;s timeline&amp;quot;
  def home_timeline
    client.home_timeline.each do |tweet|
      puts &amp;quot;@#{tweet.user.user_name}:#{tweet.text}&amp;quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show which of their tweets have been retweeted:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;retweets&amp;quot;, &amp;quot;Show the authenticated user&amp;#39;s retweets&amp;quot;
  def retweets
    client.retweets_of_me.each do |tweet|
      puts &amp;quot;@#{tweet.user.user_name}:#{tweet.text}&amp;quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pull down only the tweets that mention the authentication user:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;mentions&amp;quot;, &amp;quot;Show the authenticated user&amp;#39;s mentions&amp;quot;
  def mentions
    client.mentions.each do |tweet|
      puts &amp;quot;@#{tweet.user.user_name}:#{tweet.text}&amp;quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are building a bot, for example, that you wanted to respond when someone tweets at it, you could use the &lt;code&gt;client.mentions&lt;/code&gt; method to get those tweets in particular.  You&amp;#39;d need a way to make sure you don&amp;#39;t double respond to people each time the bot was run.  If you wanted to always have the bot running, look at the Streaming API below.  If you want to know how to post to twitter, read on.&lt;/p&gt;

&lt;h2&gt;Rate Limits on the REST interface&lt;/h2&gt;

&lt;p&gt;Unlike Google, who casually has enough computer power to do personalized type ahead search of the &lt;em&gt;entire internet&lt;/em&gt; at &lt;em&gt;a global scale&lt;/em&gt;, Twitter is prickly about &lt;a href="https://dev.twitter.com/rest/public/rate-limiting"&gt;you hammering their site&lt;/a&gt;.  Personally, I thought that &lt;a href="http://readwrite.com/2008/07/17/the_story_of_the_fail_whale"&gt;the fail whale&lt;/a&gt; was really fun.  Let&amp;#39;s add a another &lt;code&gt;CLI&lt;/code&gt; command to print out the current rate limit status, how many calls you have left, and when your counter for that resource will reset:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;limits&amp;quot;, &amp;quot;Print out the current rate limits&amp;quot;
  def limits
    resp = client.get( &amp;quot;/1.1/application/rate_limit_status.json&amp;quot; )
    current_time = Time.now.to_i
    template = &amp;quot;   %-40s %5d remaining, resets in %3d seconds\n&amp;quot;
    resp.body[:resources].each do |category,resources|
      puts category.to_s
      resources.each do |resource,info|
        printf template, resource.to_s, info[:remaining], info[:reset] - current_time
      end
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I&amp;#39;m making the request using &lt;code&gt;client.get&lt;/code&gt; which will make an arbitrary authenticated request to the Twitter api.  This &lt;a href="https://dev.twitter.com/rest/reference/get/application/rate_limit_status"&gt;particular api call&lt;/a&gt; isn&amp;#39;t in the Twitter gem, though the gem is aware of the limits and will throw specific exceptions when you hit those limits.&lt;/p&gt;

&lt;p&gt;The gem provides methods on top of this &lt;code&gt;client.get&lt;/code&gt; interface, which may use more API calls then you expect.  Methods like &lt;code&gt;client.user_timeline&lt;/code&gt; and &lt;code&gt;client.followers&lt;/code&gt; return &lt;code&gt;Twitter::Cursor&lt;/code&gt; objects, which you can iterate over in ruby as you&amp;#39;d expect, but may trigger multiple API calls throughout the process which you might not expect.  You&amp;#39;ll potentially get an exception in the middle of things, and you&amp;#39;ll need to figure a way around this.  In a later post we will get into caching and retry strategies, but since it will dramatically increase the complexity we&amp;#39;ll keep things simple for now.  &lt;em&gt;Punt!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This basic code will catch the &lt;code&gt;TooManyRequests&lt;/code&gt; exception and sleep the process until it&amp;#39;s ready to go again.  This could take a very very long time.
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:source/2014-11-20-scripting-twitter.html.markdown&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;follower_ids = client.follower_ids(&amp;#39;justinbieber&amp;#39;)
=======

```rb
follower_ids = client.follower_ids( &amp;#39;justinbieber)
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 67530e9afbddd730c4fe8e19235236777450322a:source/drafts/scripting-twitter.html.markdown

begin
  follower_ids.to_a
rescue Twitter::Error::TooManyRequests =&amp;gt; error
  # NOTE: Your process could go to sleep for up to 15 minutes but if you
  # retry any sooner, it will almost certainly fail with the same exception.
  sleep error.rate_limit.reset_in + 1
  retry
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Listing followers&lt;/h2&gt;

&lt;p&gt;To see what that looks like, lets add another &lt;code&gt;CLI&lt;/code&gt; command for listing a person&amp;#39;s followers:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;followers SCREENNAME&amp;quot;, &amp;quot;Prints out all of the users followers&amp;quot;
  def followers( screenname )
    client.followers( screenname ).each do |u|
      printf( &amp;quot;@%-15s %-20s %s\n&amp;quot;, u.user_name, u.name, u.description )
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if we run this on someone will a lot of followers, you&amp;#39;ll see the &lt;code&gt;Twitter::Error::TooManyRequests&lt;/code&gt; thrown.  We can look use our limits command above to see how long we have to wait until it resets.  Though, since we don&amp;#39;t have any smart retrying logic in place, chances are it will still fail when we try it again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby twitter.rb limits | grep /followers/list
   /followers/list        0 remaining, resets in 288 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Searching for URLs&lt;/h2&gt;

&lt;p&gt;There are different types of URLs on twitter.  Lets look at a specific tweet of mine, 529342690476179456, to see what there is:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;&amp;gt; tweet = client.status( 529342690476179456 )
 =&amp;gt; #&amp;lt;Twitter::Tweet id=529342690476179456&amp;gt; 
&amp;gt; tweet.uris
 =&amp;gt; [#&amp;lt;Twitter::Entity::URI:0x007ff614b0fce0 @attrs={:url=&amp;gt;&amp;quot;http://t.co/frfwwIqrYB&amp;quot;, :expanded_url=&amp;gt;&amp;quot;http://willschenk.com/bootstrap-advanced-grid-tricks&amp;quot;, :display_url=&amp;gt;&amp;quot;willschenk.com/bootstrap-advaâ€¦&amp;quot;, :indices=&amp;gt;[67, 89]}&amp;gt;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;:url&lt;/code&gt; is the actual link that get&amp;#39;s clicked, and in your logs, the one that will show up as the referer.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:expanded_url&lt;/code&gt; is the end link.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:display_url&lt;/code&gt; is a shortened version of the end link.&lt;/p&gt;

&lt;p&gt;In the twitter search box we can type in &lt;code&gt;http://willschenk.com/bootstrap-advanced-grid-tricks&lt;/code&gt; and that will match all tweets that go to this URL, regardless of which URL shortening service they use.  (To clarify, all those services which Twitter has support for, which for our purposes is all.)  If we type in &lt;code&gt;http://t.co/frfwwIqrYB&lt;/code&gt; to the twitter search it won&amp;#39;t match the tweet, but if we do &lt;em&gt;an exact search&lt;/em&gt;, with quotes around it like so: &lt;code&gt;&amp;quot;http://t.co/frfwwIqrYB&amp;quot;&lt;/code&gt; we will match the tweet.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s write some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;search STRING&amp;quot;, &amp;quot;Shows all the tweets that match the string&amp;quot;
  options [:exact, :user_info]
  def search( string )
    string = &amp;quot;\&amp;quot;#{string}\&amp;quot;&amp;quot; if options[:exact]
    reach = 0
    client.search( string, count: 100 ).each do |t|
      puts &amp;quot;#{t.id}:#{t.created_at}:@#{t.user.user_name}:#{t.user.followers_count}:#{t.retweet_count}:#{t.text}&amp;quot;
      reach += t.user.followers_count
      if options[:user_info]
        print_user_info t.user if options[:user_info]
        puts
      end
    end
    puts &amp;quot;#{string} reached #{reach} people.&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print out the tweet id, when it was created, who tweeted it, how many followers they had, how many times it was retweeted, and the text of the tweet.  &lt;em&gt;Whew!&lt;/em&gt; Since there&amp;#39;s so much stuff here we made it &lt;code&gt;:&lt;/code&gt; separated on one line, in case you want to parse it with something else.&lt;/p&gt;

&lt;p&gt;The option &lt;code&gt;--exact&lt;/code&gt; will put quotes around the search string, so if you are looking up a tweet from your referrers you can find which tweet sent people to your site.&lt;/p&gt;

&lt;p&gt;The option &lt;code&gt;--user_info&lt;/code&gt; will print out the full information about the user who tweeted.&lt;/p&gt;

&lt;p&gt;Twitter search only returns results from the previous 6-9 days, so better act fast!&lt;/p&gt;

&lt;h2&gt;The Streaming API: Filters&lt;/h2&gt;

&lt;p&gt;So far we have been looking at the REST API, which lets us interact with the Twitter services much like a user would: in response to something that the user requests.  The other API type is called the &lt;a href="https://dev.twitter.com/streaming/userstreams"&gt;streaming api&lt;/a&gt;, which lets us open up a single connection and receive information when Twitter has something new.  This is useful for a few things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We can get notified immediately when our search term is seen&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We can get notified if someone mentions us, either with an @reply or, when we have more permissions, with Direct Messages.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here&amp;#39;s how you can watch twitter for different terms, they can be comma separated.  Notice that we&amp;#39;ve added another private method, &lt;code&gt;streaming_client&lt;/code&gt; which uses a different interface, and we&amp;#39;ll need to &lt;code&gt;^C&lt;/code&gt; the script to start it.&lt;/p&gt;

&lt;p&gt;The method &lt;code&gt;filter&lt;/code&gt; takes a block, and will call that block every time it gets a response from twitter.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;filter TERMS&amp;quot;, &amp;quot;Print out tweets that match the terms&amp;quot;
  def filter( terms )
    streaming_client.filter(track: terms) do |object|
      puts &amp;quot;@#{object.user.user_name}:#{object.text}&amp;quot; if object.is_a?(Twitter::Tweet)
    end
  end


  private
  [...]

  def streaming_client
    @streaming_client ||= Twitter::Streaming::Client.new do |config|
      config.consumer_key        = TWITTER_APP_KEY
      config.consumer_secret     = TWITTER_APP_SECRET
      config.access_token        = TWITTER_ACCESS_TOKEN
      config.access_token_secret = TWITTER_ACCESS_TOKEN_SECRET
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;The Streaming API: Reacting to the timeline&lt;/h2&gt;

&lt;p&gt;We can also watch the timeline come through for the registered user, and do something with it.  The pattern is the same as the &lt;code&gt;filter&lt;/code&gt; method, but it passes an Object of one of the following types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Twitter::Tweet&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Twitter::DirectMessage&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Twitter::Streaming::DeletedTweet&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Twitter::Streaming::Event&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Twitter::Streaming::FriendList&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Twitter::Streaming::StallWarning&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;#39;ll be ignoring most of them:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;listen&amp;quot;, &amp;quot;Prints our the authenticated user&amp;#39;s stream as it happens&amp;quot;
  def listen
    streaming_client.user do |object|
      case object
      when Twitter::Tweet
        puts &amp;quot;Tweet:@#{object.user.user_name}:#{object.text}&amp;quot;
      when Twitter::DirectMessage
        puts &amp;quot;DM:@#{object.sender.user_name}:#{object.text}&amp;quot;
      when Twitter::Streaming::StallWarning
        warn &amp;quot;Falling behind!&amp;quot;
      end
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this command will print out tweets and messages as they come in.  If you wanted to make an interactive bot, you&amp;#39;d put logic in here to respond to the tweets coming in, calling something like&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;client.update( &amp;quot;@#{object.user.user_name} my reply&amp;quot;, { in_reply_to_status: object.id } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only, you&amp;#39;re not going to get any direct messages, nor are you going to be able to reply, unless you change your application permission settings.&lt;/p&gt;

&lt;h2&gt;Upgrading to the All Access Pass&lt;/h2&gt;

&lt;p&gt;In order to&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Update a status&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Read direct messages&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Send direct messages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You need to change the application permission level.  There are three different levels.  Read will let you pull things on behalf of the user.  If they have a private account, or they have access to a private account, your script will be able to see those things.  You will not be able to access or receive direct messages&lt;/p&gt;

&lt;p&gt;Write will let you post public status updates, but not Direct Messages.&lt;/p&gt;

&lt;p&gt;Access direct messages is the third.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Go to the &lt;a href="https://apps.twitter.com"&gt;twitter app console&lt;/a&gt; and find your application.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Go to the &amp;quot;Permissions Tab&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Change the settings to &amp;quot;Read, Write&amp;quot; or &amp;quot;Read, Write and Access direct messages&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Go to &amp;quot;Keys and Access Settings&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scroll down and &amp;quot;Regenerate My Access Token and Token Secret&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Depending upon what you chose, you can now post on behalf of the user:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;client.update( &amp;quot;Hello, World&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read their direct messages:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;client.direct_messages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or send a direct message:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;client.create_direct_message &amp;quot;wschenk&amp;quot;, &amp;quot;Hi there&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;The Code&lt;/h2&gt;

&lt;p&gt;Here is the &lt;a href="https://gist.github.com/wschenk/86e1e87772e7d589e963"&gt;code written for this article&lt;/a&gt;.  The github for &lt;a href="https://github.com/sublimeguile/socialinvestigator"&gt;socialinvestigator&lt;/a&gt; has a more complete sample that loads and stores the credentials in a file.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Image Credit &lt;a href="https://www.flickr.com/photos/jurvetson/7408451314/in/photolist-bvcbis-7DN6Sk-7DRVeq-7DRUVq-jB3M44-dhZrKM-atAnS1-bi4yL6-atHJJo-85tMTG-cp5WgS-asg29e-chEftd-6Zex9h-djkSiW-acqro-c7PG79-72SJuQ-7fPiox-avgwDx-bEWnc2-4FAqy9-9mvMsP-8fp27H-chEjh3-66UgvR-6oqRAV-6oqUMD-5zWDAn-9mqRC4-6ov3Mw-6oqRQZ-6ov4bh-avgxEZ-6VXNYF-avgwMM-avjcLf-avjcQ1-avjcLS-avjcPd-avjcTW-avjduE-avgwZK-avjdMm-avjcVy-avjcSU-avgwRt-avjcY1-avjd2d-avgwTv"&gt;Steve Jurvetson&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Embedding 3d models on your page</title>
    <link rel="alternate" href="http://willschenk.com/embedding-3d-models-on-your-page/"/>
    <id>http://willschenk.com/embedding-3d-models-on-your-page/</id>
    <published>2014-11-15T19:00:00-05:00</published>
    <updated>2014-11-15T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Github has an &lt;a href="https://help.github.com/articles/3d-file-viewer/"&gt;embeddable 3d model viewer&lt;/a&gt; that you can use to display a model on your site.  The model needs to be hosted in a github repo, and the format is&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://embed.github.com/view/3d/&amp;lt;username&amp;gt;/&amp;lt;repo&amp;gt;/&amp;lt;ref&amp;gt;/&amp;lt;path_to_file&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s a model of me that we made using the (Structure 3d scanner)[&lt;a href="http://structure.io"&gt;http://structure.io&lt;/a&gt;], which is a fun device that plugs into your iPhone or iPad.&lt;/p&gt;

&lt;p&gt;&lt;script src="https://embed.github.com/view/3d/sublimeguile/model_army/master/will%20clean.stl"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Pretty fun right?&lt;/p&gt;

&lt;p&gt;The next thing you need to do is to get a 3d printer, so you can create action figures for your office.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Silvrback blog image" src="https://silvrback.s3.amazonaws.com/uploads/f685deb9-2974-425c-bb5b-6d6727b33159/10514107_312439818930875_824765904_n_large.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;End.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Personal information from only a URL</title>
    <link rel="alternate" href="http://willschenk.com/personal-information-from-only-a-url/"/>
    <id>http://willschenk.com/personal-information-from-only-a-url/</id>
    <published>2014-11-13T19:00:00-05:00</published>
    <updated>2014-11-13T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Ever wonder what you can find out by looking at a url?  How about physical addresses, server location, emails, phone numbers, various links to other profiles (which can in turn be structurally scraped), technology stack, and more. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ socialinvestigator net page http://willschenk.com/bio
              domain: willschenk.com
          created_on: 2014-10-31
          expires_on: 2015-10-31
          updated_on: 2014-10-31
      registrar_name: ENOM, INC.
       registrar_url: www.enom.com
  registrant_contact: 
                     name: WILL SCHENK
             organization: HAPPYFUNCORP
                  address: 18 BRIDGE STREET, 2E
                     city: BROOKLYN
                      zip: 11201
                    state: NY
             country_code: US
                    phone: +91.76976430
                    email: WSCHENK@GMAIL.COM
         server_name: ec2-54-225-218-167.compute-1.amazonaws.com
      server_country: United States
     server_location: Ashburn, Virginia
     server_latitude: 39.0437
    server_longitude: -77.4875
     server_ip_owner: Amazon Technologies Inc. (AT-88-Z)
              emails: wschenk@gmail.com, will@happyfuncorp.com
               title: Will Schenk
         description: The blog of Will Schenk
      twitter_author: wschenk
         twitter_ids: wschenk
          responsive: true
            rss_feed: /feed.rss
           atom_feed: /feed
       twitter_links: https://twitter.com/wschenk, http://twitter.com/wschenk
      linkedin_links: http://www.linkedin.com/pub/will-schenk/0/266/420/
     instagram_links: http://instagram.com/wschenk
        github_links: https://github.com/wschenk
        technologies: Chartbeat, Font Awesome, Google Analytics, RackCache, Ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Standalone code as &lt;a href="https://gist.github.com/wschenk/7d333acb59b7768f2637"&gt;a gist&lt;/a&gt;, the complete socialinvestigator code &lt;a href="https://github.com/sublimeguile/socialinvestigator"&gt;available on github&lt;/a&gt; or and is easily installable on your machine as a gem.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install socialinvestigator
$ socialinvestigator net get_apps_json
$ socialinvestigator net page_info url
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Poking around different urls can give you a sense of the corporate entities behind sites, who is actually involved, and help you track down people when you can&amp;#39;t find them otherwise.  It&amp;#39;s actually hard to figure out which URL to include on this post since the data seems so personal and yet people put it out there.  This takes the messy HTML that&amp;#39;s out there and returns structured information that you can use to explore profiles on other sites in a way that can be totally automated.&lt;/p&gt;

&lt;h2&gt;What does it do?&lt;/h2&gt;

&lt;p&gt;What this code does is to first search for DNS information to see who owns the domain and if there&amp;#39;s any contact information associated with it.  It then looks at who owns the IP address and tries to locate where it is geographically.&lt;/p&gt;

&lt;p&gt;It then looks at the page itself to see &lt;a href="http://ogp.me"&gt;Open Graph meta data&lt;/a&gt;,&lt;a href="https://dev.twitter.com/cards/overview"&gt;Twitter Card meta data&lt;/a&gt; and other basic SEO tags.&lt;/p&gt;

&lt;p&gt;Finally, it looks inside the page for likely looking links to other social networks, and scans the page and HTTP metadata for clues about what underlying technology the site was built in.  (The metadata for the technology fingerprinting is from the &lt;a href="https://github.com/ElbertF/Wappalyzer"&gt;Wappalyzer project&lt;/a&gt; which I cobbled together a basic ruby engine for.)&lt;/p&gt;

&lt;p&gt;And finally it takes all of the facts that it has collected, figured out which ones take priority, and prints them out.&lt;/p&gt;

&lt;h2&gt;Finding Domain info&lt;/h2&gt;

&lt;p&gt;The first thing that we do is look for the URL and try to find the domain name.  The difference between a hostname and domain name is subtle, partly in some cases they are interchangeable, and partly because DNS is the &lt;a href="http://codex.happyfuncorp.com/slides/93#1"&gt;second most amazing thing about the Internet&lt;/a&gt;.  (The most truly mind-blowing thing clearly &lt;a href="http://en.wikipedia.org/wiki/Default_route"&gt;the default route&lt;/a&gt;, the &lt;em&gt;life, liberty, and pursuit of happiness&lt;/em&gt; of the Internet.)  A globe spanning, highly distributed database that lets 2.5 billion internet users look up any of the 4 billion potential server addresses in less than 50ms without any real centralized control isn&amp;#39;t exactly straightforward.&lt;/p&gt;

&lt;p&gt;DNS manages this complexity by delegating authority for different branches of the entire namespace.  The first level is called the Top Level Domains, most famous being &lt;em&gt;.com&lt;/em&gt;, when you buy a domain name from someone they delegate authority over that name space to you.  These can go deep, especially with large global organizations.  The first thing we do is look for that &lt;strong&gt;Start of Authority&lt;/strong&gt; (SOA) record for machine named in the URL.  If we can&amp;#39;t find one for that machine, we look up the chain until we find something.&lt;/p&gt;

&lt;p&gt;This looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;dnsruby&amp;#39;

hostname = URI(url).hostname

def find_domain( hostname )
  puts &amp;quot;Looking for SOA of #{hostname}&amp;quot;
  dns = Dnsruby::Resolver.new
  soa = dns.query( hostname, &amp;quot;SOA&amp;quot; ).answer.select do |rr|
    rr.is_a? Dnsruby::RR::IN::SOA
  end

  return hostname if soa.length &amp;gt; 0

  # Go from &amp;quot;news.bbc.co.uk&amp;quot; -&amp;gt; &amp;quot;bbc.co.uk&amp;quot;
  parts = hostname.split( /\./ )
  return nil if parts.length &amp;lt;= 2

  find_domain( parts.slice(1,100).join( &amp;quot;.&amp;quot; ) )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;#39;ve found the domain, we query the &lt;code&gt;whois&lt;/code&gt; databases to find out who has owns the domain name.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;whois&amp;#39;

whois = Whois.lookup( domain )

puts &amp;quot;Expires: #{whois.expires_on}&amp;quot;
# Print all contact information we find
whois.contacts.each { |c| puts c }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the challenges here is that there is no standardized format that there is no standardized way of parsing &lt;code&gt;whois&lt;/code&gt; responses.  The &lt;code&gt;whois&lt;/code&gt; gem gives it a serious try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l `bundle show whois`/lib/whois/record/parser | wc -l
     209
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there&amp;#39;s over 500 different whois servers out there, so you won&amp;#39;t always get a parseable response.  In that case we print out that we can&amp;#39;t find a parser, and we store the unparsed response in the data object as &lt;code&gt;unparsed_whois&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;whois.parts.each do |p|
  # Check for responses that we couldn&amp;#39;t parse
  if Whois::Record::Parser.parser_for(p).is_a? Whois::Record::Parser::Blank
    puts &amp;quot;Couldn&amp;#39;t find a parser for #{p.host}:&amp;quot;
    puts p.body
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Finding IP and hosting information&lt;/h2&gt;

&lt;p&gt;Now we look at the IP address, and then do a reverse lookup on it to see what the server machine name is.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;ip_address = Dnsruby::Resolv.getaddress uri.host

data.remember :ip_address, ip_address
begin
  data.remember :server_name, Dnsruby::Resolv.getname( ip_address )
rescue Dnsruby::NXDomain
  # Couldn&amp;#39;t do the reverse lookup
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes interesting things are encoded in the server name, like if it&amp;#39;s a Rackspace cloud server vs a Rackspace static server, but we make no attempt to interpret that string.&lt;/p&gt;

&lt;p&gt;Then we try and see where the IP address is located geographically, using &lt;a href="http://freegeoip.net/"&gt;freegeoip.net&lt;/a&gt;.  If you did a lot of this it would make sense to buy a more detailed database from &lt;a href="https://www.maxmind.com/en/home"&gt;Maxmind&lt;/a&gt; but for something quick and dirty this works.  Given that you need to follow the rules of the company you are in, it&amp;#39;s interesting to see where the servers are located.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;location_info = HTTParty.get(&amp;#39;http://freegeoip.net/json/&amp;#39; + ip_address)

data.remember :server_country, location_info[&amp;#39;country&amp;#39;]
data.remember :server_location, [location_info[&amp;#39;city&amp;#39;], location_info[&amp;#39;region_name&amp;#39;]].select { |x| x }.join( &amp;quot;, &amp;quot;)
data.remember :server_latitude, location_info[&amp;#39;latitude&amp;#39;]
data.remember :server_longitude, location_info[&amp;#39;longitude&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also do a &lt;code&gt;whois&lt;/code&gt; lookup on the IP address, to see who owns that IP block.  This should give us an idea of who is hosting the site.  Note that we don&amp;#39;t even pretend to parse the &lt;code&gt;whois&lt;/code&gt; response here in a clever way.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;ip_whois = Whois.lookup ip_address

ip_whois.to_s.each_line.select { |x| x=~/Organization/ }.each do |org|
  if org =~ /Organization:\s*(.*)\n/
    data.another :server_ip_owner, $1
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Page meta data&lt;/h2&gt;

&lt;p&gt;Now we load up the page, and look for some basic stuff.  The first thing that we do is load the &lt;a href="http://en.wikipedia.org/wiki/Meta_element"&gt;meta tags&lt;/a&gt; into something more accessible.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;response = HTTParty.get url
parsed = Nokogiri.parse response.body

# Meta tags

meta = {}
parsed.css( &amp;quot;meta[name]&amp;quot; ).each do |t|
  meta[t.attributes[&amp;quot;name&amp;quot;].value] = t.attributes[&amp;quot;content&amp;quot;].value if t.attributes[&amp;quot;content&amp;quot;]
end

parsed.css( &amp;quot;meta[property]&amp;quot; ).each do |t|
  meta[t.attributes[&amp;quot;property&amp;quot;].value] = t.attributes[&amp;quot;content&amp;quot;].value
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we load up some basic SEO info, including if there are any feeds for this site&amp;#39;s content.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;data.remember( :author, meta[&amp;#39;author&amp;#39;] ) 
data.remember( :description, meta[&amp;#39;description&amp;#39;] ) 
data.remember( :keywords, meta[&amp;#39;keywords&amp;#39;] ) 
data.remember( :generator, meta[&amp;#39;generator&amp;#39;])
data.remember( :responsive, true )  if meta[&amp;quot;viewport&amp;quot;] =~ /width=device-width/
data.remember( :server, response.headers[&amp;#39;server&amp;#39;] )
data.remember( :page_title, parsed.title )

# RSS Feed:
if feed = parsed.css( &amp;#39;link[type=&amp;quot;application/rss+xml&amp;quot;]&amp;#39; ).first
  feed = feed.attributes[&amp;#39;href&amp;#39;].value
  data.remember( :rss_feed, feed )
end

# Atom Feed:
if feed = parsed.css( &amp;#39;link[type=&amp;quot;application/atom+xml&amp;quot;]&amp;#39; ).first
  feed = feed.attributes[&amp;#39;href&amp;#39;].value
  data.remember( :atom_feed, feed )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Twitter Cards&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://dev.twitter.com/cards/overview"&gt;Twitter Card meta data&lt;/a&gt; is a way to control how your data gets displayed on twitter, which has the benefit of defining some summary meta data around the social graph.  One thing thing to note is that &lt;code&gt;twitter:creator&lt;/code&gt; is the author of this page, while &lt;code&gt;twitter:site&lt;/code&gt; is the twitter account for the overall site.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;data.remember( :twitter_title, meta[&amp;quot;twitter:title&amp;quot;] ) 
data.remember( :twitter_creator, meta[&amp;quot;twitter:creator&amp;quot;] ) 
if /@(.*)/.match( meta[&amp;quot;twitter:creator&amp;quot;] )
  data.another( :twitter_ids, $1 )
end
data.remember( :twitter_site_author, meta[&amp;quot;twitter:site&amp;quot;] )
if /@(.*)/.match( meta[&amp;quot;twitter:site&amp;quot;] )
  data.another( :twitter_ids, $1 )
end
data.remember( :twitter_image, meta[&amp;quot;twitter:image&amp;quot;] ) 
data.remember( :twitter_description, meta[&amp;quot;twitter:description&amp;quot;] )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Open Graph&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://ogp.me"&gt;Open Graph meta data&lt;/a&gt; is really about what your link looks like when someone shares it on Facebook.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;data.remember( :og_title, meta[&amp;quot;og:title&amp;quot;] ) 
data.remember( :og_description, meta[&amp;quot;og:description&amp;quot;] )
data.remember( :og_type, meta[&amp;quot;og:type&amp;quot;] ) 
data.remember( :og_image, meta[&amp;quot;og:image&amp;quot;] ) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Social Page Links&lt;/h2&gt;

&lt;p&gt;We search for social links:&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Regex&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Email&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/mailto:(.*@.*\..*)/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Twitter&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/twitter.com\/[^\/]*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LinkedIn&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/linkedin.com/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Instagram&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/instagram.com/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Facebook&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/facebook.com\/[^\/]*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Google+&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/plus.google.com\/[^\/]*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Github&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/github.com\/[^\/]*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;For Twitter, Facebook, and Google+ we are only letting through links that have a simple query string, since for the most part this means that it&amp;#39;s the user&amp;#39;s ID.&lt;/p&gt;

&lt;h2&gt;Parsing Twitter Shares and Intents&lt;/h2&gt;

&lt;p&gt;We then look for Twitter Share links, and try and parse out the user names found in there.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Look for twitter shared links

twitter_shared = matching_links( parsed, /twitter.com\/share/ )

twitter_shared.each do |l|
  text = l[&amp;#39;data-text&amp;#39;]

  # See if there&amp;#39;s a &amp;quot;by @user&amp;quot; in the text
  if /by\s*@([^\s]*)/.match text
    data.another( :twitter_ids, $1 )
    data.remember( :twitter_by, $1 ) 
  end

  # Look for all &amp;quot;@usernames&amp;quot; in the text
  if text
    text.split.select { |x| x =~ /@\s*/ }.each do |id|
      data.another( :twitter_ids, id.slice( 1,100 ) ) # We don&amp;#39;t want the @
    end
  end

  # See if there&amp;#39;s a via link on the anchor tag
  if l[&amp;#39;data-via&amp;#39;]
    data.another( :twitter_ids, l[&amp;#39;data-via&amp;#39;])
  end

  possible_via = URI.decode( (URI(l[&amp;#39;href&amp;#39;]).query) || &amp;quot;&amp;quot; ).split( /&amp;amp;amp;/ ).collect { |x| x.split( /=/  ) }.select { |x| x[0] == &amp;#39;via&amp;#39; }
  if possible_via.size &amp;gt; 0
    data.another( :twitter_ids, possible_via[0][1] )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are also twitter intent links:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;twitter_intent = hrefs( matching_links( parsed, /twitter.com\/intent/ ) )

twitter_intent.each do |t|
  URI.decode( URI(t.gsub( / /, &amp;quot;+&amp;quot; )).query ).split( /&amp;amp;/ ).select do |x| 
    x =~ /via/
  end.collect do |x| 
    x.gsub( /via=/, &amp;quot;&amp;quot; )
  end.each do |via|
    data.another( :twitter_ids, via )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Technology Finger Prints&lt;/h2&gt;

&lt;p&gt;The final thing we do is to load the &lt;code&gt;apps.json&lt;/code&gt; file from &lt;a href="https://github.com/ElbertF/Wappalyzer"&gt;Wappalyzer&lt;/a&gt; which is a cross-platform utility that uncovers the technologies used on websites.  This has a list of regex for the header tags, meta tags, scripts and other parts of the html to make guesses about which technology is in place.  What is in place is very rudimentary, but it gives a general sense of what is used to made the site.&lt;/p&gt;

&lt;h2&gt;Installation&lt;/h2&gt;

&lt;p&gt;The standalone code as &lt;a href="https://gist.github.com/wschenk/7d333acb59b7768f2637"&gt;a gist&lt;/a&gt;, and you can check out the complete &lt;a href="https://github.com/sublimeguile/socialinvestigator"&gt;socialinvestigator code on github&lt;/a&gt;.  To run this on your machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install socialinvestigator
$ socialinvestigator net get_apps_json
$ socialinvestigator net page_info http://willschenk.com/bio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It may take a while to get the responses.  If you want to see everything it&amp;#39;s doing, use the &lt;code&gt;--debug&lt;/code&gt; switch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ socialinvestigator net page_info http://willschenk.com/bio --debug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reverse lookup can take a while, and if you want to turn that off:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ socialinvestigator net page_info http://willschenk.com/bio --noreverse
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Bot Design Patterns</title>
    <link rel="alternate" href="http://willschenk.com/bot-design-patterns/"/>
    <id>http://willschenk.com/bot-design-patterns/</id>
    <published>2014-11-10T19:00:00-05:00</published>
    <updated>2014-11-10T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;In the antediluvian days before Google found everything for us, personal &lt;em&gt;software agents&lt;/em&gt; were going to continuously do our bidding in &lt;em&gt;cyberspace&lt;/em&gt;, tracking down air fares, making stock trades and otherwise doing futuristic things that we soon wouldn&amp;#39;t be able to live without.  The anxiety of Y2K rose and crested, and the messianic aura of &lt;em&gt;agents&lt;/em&gt; was washed away by more centralized and effective solutions.&lt;/p&gt;

&lt;p&gt;The aspirational residue did yield some nuggets, and the idea has found partial success in the form of the &lt;em&gt;bot&lt;/em&gt;. In the popular imagination bots exist on &lt;a href="http://www.newyorker.com/tech/elements/the-rise-of-twitter-bots"&gt;Twitter as art projects&lt;/a&gt; or as &lt;a href="http://www.nytimes.com/2013/08/11/sunday-review/i-flirt-and-tweet-follow-me-at-socialbot.html?_r=0"&gt;marketing machines&lt;/a&gt; or as &lt;a href="http://www.radiolab.org/story/137407-talking-to-machines/"&gt;the perfect online dating scandal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Bots can be characterized by asking a few questions, and from these answers we can tell something about their implementation and what it takes to build one:  &lt;strong&gt;Do they react to messages?&lt;/strong&gt; &lt;strong&gt;Do they know who they are talking to?&lt;/strong&gt; &lt;strong&gt;Can they learn from what was said?&lt;/strong&gt; &lt;strong&gt;Do they know where the conversation is taking place?&lt;/strong&gt;  &lt;strong&gt;Do they remember the overall conversation?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;From this, we can classify bots into one of six types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Notifiers&lt;/li&gt;
&lt;li&gt;Reactors&lt;/li&gt;
&lt;li&gt;Space Reactors&lt;/li&gt;
&lt;li&gt;Responders&lt;/li&gt;
&lt;li&gt;Space Responders&lt;/li&gt;
&lt;li&gt;Conversationists&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of these have progressively more complex context that the bot is operating in.  Most chat mediums have different message types, where message can be directed towards or private to a particular user.  Confounding things further, some have a native concept of &lt;em&gt;spaces&lt;/em&gt;, generally called a &lt;em&gt;room&lt;/em&gt; or a &lt;em&gt;channel&lt;/em&gt;, and as we treat people differently in different context the bot will also need to be aware of the difference context that the conversion is taking place.  We can call those services &lt;em&gt;Spaced&lt;/em&gt;.&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Spaced&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SMS&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Groups are a dynamic list of people&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Desktop Notifications&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Stuck on one computer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Push Notifications&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;One way communication&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://www.aim.com"&gt;AIM&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Group chat not core usage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://support.google.com/chat/answer/159495?hl=en"&gt;GChat&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Group chat not core usage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://www.apple.com/ios/messages/"&gt;iMessage&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Groups are a dynamic list of people&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="http://twitter.com/"&gt;Twitter&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Lists aren&amp;#39;t groups&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://www.yammer.com"&gt;Yammer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Sorta&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat"&gt;IRC&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Channels&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://www.hipchat.com"&gt;HipChat&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Rooms&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://slack.com"&gt;Slack&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href="https://campfirenow.com"&gt;Campfire&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Rooms&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Keeping track of User / Space context is more challenging than just User context&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;Notifiers&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Notifiers&lt;/em&gt; are the &amp;quot;simplest type&amp;quot;of bots, in the sense that the messaging logic is a minor part of the overall program.  As a consequence they are the most common and the most varied.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Broadcast a message based upon an external source&lt;/li&gt;
&lt;li&gt;Don&amp;#39;t react to messages, so the answers to all the other questions are irrelevant.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The trick in &lt;em&gt;Notifiers&lt;/em&gt; is in figuring out what to say, not sending the message.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Twitter Example
message = &amp;quot;Hello, World&amp;quot;
client.update( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="sh"&gt;# AppleScript from the command line example
$ MESSAGE=&amp;quot;Hello, World&amp;quot;
$ /usr/bin/osascript -e &amp;quot;display notification \&amp;quot;$MESSAGE\&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Using the terminal-notifier gem
require &amp;#39;terminal-notifier&amp;#39;
TerminalNotifier.notify &amp;quot;\u2705 green!&amp;quot;, :title =&amp;gt; &amp;quot;Hello, World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are best implemented by having one program generate the information, and sending that to another program that sends the message to the chat service.  This could be a monitoring agent that is checking to see if a URL is responding, and if not, sends an alert.  It could be a build process that returns a success or failure message.  &lt;/p&gt;

&lt;p&gt;It could be a program that selects &amp;quot;the next word&amp;quot; from a lists of words and tweets one out every hour.  Or it could make a bunch of API calls to different services, correlate that with information from a database, do more complicated calculations, and then post it.  There&amp;#39;s a bot that monitors the top links on hacker news, so it needs to pull down a list of top content, keep track of if it&amp;#39;s tweeted it out before, and then send out the message.  The sending part is simple, but the overall bot may not be.&lt;/p&gt;

&lt;h2&gt;Reactors&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Reactors&lt;/em&gt; take action based upon incoming messages, but have no memory of who it&amp;#39;s talking with or what space it&amp;#39;s talking in.  The who and where maybe in the message headers, and the bot can return the message in the correct place, but there is no bot-persisted memory of them.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reacts to messages on the chat service&lt;/li&gt;
&lt;li&gt;Doesn&amp;#39;t remember anything that was said&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The basic idea is that a reactor gets a message, does something with it, and moves on.  A lot of twitter bots follow this pattern, where they are looking at things on the stream and commenting upon them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on_message( message ) = -&amp;gt;
  result = act_on_message( message )
  message.reply( result )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, here&amp;#39;s something that listens for tweets matching the string &lt;code&gt;not a feminist&lt;/code&gt; and reacts by tweeting that that user isn&amp;#39;t a feminist:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;streaming_client.filter(track: &amp;quot;not a feminist&amp;quot;) do |object|
  if object.is_a?( Twitter::Tweet ) &amp;amp;&amp;amp; object.user.user_name != BOT_NAME
    client.update( &amp;quot;. @#{object.user.user_name} is not a feminist&amp;quot; )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It could do something more interesting, like looking for an image url, downloading it, running it through ImageMagick, posting it to S3, and then tweeting it back out.  But since the bot itself keeps no message or user state, we consider it a &lt;em&gt;reactor&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Message Dispatching&lt;/h2&gt;

&lt;p&gt;Here we reach a phase change in the level of ambient complexity of the bot.  Simple &lt;em&gt;Reactors&lt;/em&gt; respond to all messages the same way, relying on the filter to select messages that it cares about.  More complex reactors need to figure out what message it&amp;#39;s being sent and reply differently:&lt;/p&gt;

&lt;p&gt;Case loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on_message( message ) = -&amp;gt;
  dispatch( message )

dispach( message ) = -&amp;gt;
  case message.text
    when /^echo/
      do_echo( message )
    else
      message.reply( &amp;quot;Don&amp;#39;t know what you mean&amp;quot; )

do_echo( message ) = -&amp;gt;
  message.reply( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Command objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on_message( message ) = -&amp;gt;
  dispatch( message )

dispatch( message ) = -&amp;gt;
  command = find_command_object( message )
  command.execute( message )

echo_command.execute( message ) = -&amp;gt;
  message.reply( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can also be done using &lt;em&gt;metaprogramming&lt;/em&gt;, something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dispatcher
  dispatch( message ) = -&amp;gt;
    if reponds_to? message.command
      self.send( message.command, message )

class MyBotClass &amp;lt; Dispatcher
  echo( message ) = -&amp;gt;
    message.reply( message )

bot = MyBotClass.new

on_message( message ) = -&amp;gt;
  bot.dispatch( message )  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is nonsense pseudo code, but a lot of chat bot libraries focus in on that area doing something very similar to what &lt;code&gt;Thor&lt;/code&gt; does for command line programs.&lt;/p&gt;

&lt;h2&gt;Space Reactors&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Space Reactors&lt;/em&gt;, in addition to having an awesome name, react to incoming messages, and know where they are receiving a message.  The bot has memory of the place, and will respond to the user differently depending upon where the conversation was taking place.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reacts to messages on the chat service&lt;/li&gt;
&lt;li&gt;Knows where its being addressed&lt;/li&gt;
&lt;li&gt;Doesn&amp;#39;t remember anything that was said&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When a reactor is run in on Spaced chat medium, it needs to factor in where the message was received.  Instead of having &lt;em&gt;user&lt;/em&gt; and &lt;em&gt;message&lt;/em&gt; to work with, it now has &lt;em&gt;user&lt;/em&gt;, &lt;em&gt;message&lt;/em&gt;, and &lt;em&gt;space&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;You can either find the space within each of the commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyBot &amp;lt; Dispatcher
  wtf( message ) = -&amp;gt;
    space = find_space_from( message )
    commit_message = space.last_commit_message
    message.reply( commit_message )

bot = MyBot.new

on_message( message ) = -&amp;gt;
  bot.dispatch( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or locate the commands inside of the space, which lets you separate out which commands are available depending the properties of the space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PublicSpaceReactor &amp;lt; Dispatcher
  wtf( message ) = -&amp;gt;
    message.reply( &amp;quot;This space has no commits&amp;quot; )

class ProjectSpaceReactor &amp;lt; Dispatcher
  wtf( message ) = -&amp;gt;
    message.reply( project.last_commit_message )

class SpaceDispatcher &amp;lt; Dispatcher
  dispatch( message ) = -&amp;gt;
    space = find_space( message )
    responder = nil
    if space.project?
      responder =  ProjectSpaceReactor.new( space.project )
    else
      responder = PublicSpaceReactor.new
    responder.dispatch( message )

bot = SpaceDispatcher.new

on_message( message ) = -&amp;gt;
  bot.dispatch( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have a HipChat bot and have a room for each company project, and you want to have the bot respond to &lt;code&gt;wtf&lt;/code&gt; with the last commit message on github.  The first thing that you need to do is look at which room the message came from, and correlate that a list of repositories, then make a Github API call, and finally post the commit message back to the room.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  # This is a lita based bot, which provides dispatching 
  # so we find the space inside of the command
  def wtf(response)
    project = find_project response.message.source.room
    message = project.last_commit_message
    response.reply message
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;find_project&lt;/code&gt; method implies that you now need to have persistent state associated with the &lt;em&gt;Space&lt;/em&gt;, in this case the unspecified &lt;code&gt;project&lt;/code&gt; object.  It&amp;#39;s not just a matter of making sure that your reply goes to the correct place, but that what you reply will changed based upon where the person said it.&lt;/p&gt;

&lt;h2&gt;Responders&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Responders&lt;/em&gt; listen for messages and remember what was said to them.  They are different from &lt;em&gt;Reactors&lt;/em&gt; because they have persisted User state, and so can learn something from the user.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reacts to messages&lt;/li&gt;
&lt;li&gt;Knows who they are talking to&lt;/li&gt;
&lt;li&gt;Can learn from what was said&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;#39;s natural here to include the dispatching inside of the object that keeps track of the user state.  Here&amp;#39;s a pseudo example of a bot that lets you update your nickname. First by loading the user inside of the Bot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class NickBot &amp;lt; Dispatcher
  nick( message ) = -&amp;gt;
    user = User.load_from_datastore( message.user )
    user.nickname = message.arg1
    user.save
    message.reply( &amp;quot;Your nick name has been updated to &amp;quot; + message.arg1 )

bot = NickBot.new

on_message( message ) = -&amp;gt;
  bot.dispatch( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it may also make sense to create different types of dispatchers for different users, in this pseudo code there are 3 different types of responders and depending upon who is sending the message different functions are available to them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AnonymousUserResponder &amp;lt; Dispatcher
  nick( message ) = -&amp;gt;
    user.nickname = message.arg1
    user.save
    message.reply( &amp;quot;Your nick name has been updated to &amp;quot; + message.arg1 )

class NamedUserResponder &amp;lt; AnonymousUserResponder
  comment( message ) = -&amp;gt;
    create_a_comment( user.nickname, message )
    message.reply( &amp;quot;Thanks for the message&amp;quot; )

class AdminResponder &amp;lt; NamedUserResponder
  restart( message ) = -&amp;gt;
    restart_server
    message.reply( &amp;quot;You&amp;#39;ve restarted the server&amp;quot; )

class UserDispatcher &amp;lt; Dispatcher
  dispatch( message ) = -&amp;gt;
    user = User.load_from_datastore( message.user )
    responder = nil
    if user.admin?
      responder = AdminResponder.new( user )
    elseif user.nickname?
      responder = NamedUserResponder.new( user )
    else
      responder = AnonymousUserResponder.new( user )
    responder.dispatch( message )

bot = UserDispatcher.new

on_message( message )
  bot.dispatch( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This example is misleading because in real life direct inherency doesn&amp;#39;t scale well, as we&amp;#39;ll see below.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;Space Responders&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Space Responder&lt;/em&gt; learn things about who is talking with them and the context in which they are speaking.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reacts to messages&lt;/li&gt;
&lt;li&gt;Knows who they are talking to&lt;/li&gt;
&lt;li&gt;Can learn from what was said&lt;/li&gt;
&lt;li&gt;Knows where its being addressed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The challenge here is how do you juggle the permutations of state.  Lets take the example of a user is an admin in one project, where they can send commands to reboot the server, and in another project they can only open new tickets.  In the basic case, you can do everything in each of your methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ServerBot &amp;lt; Dispatcher
  restart( message ) = -&amp;gt;
    user = find_user( message )
    space = find_space( message )
    if space.is_admin?( user )
      restart_server
      message.reply( &amp;quot;Go go go&amp;quot; )
    else
      message.reply( &amp;quot;Sorry Charlie, try again&amp;quot; )

  ticket( message ) = -&amp;gt;
    space = find_space( message )
    ticket = space.create_ticket_message( message )
    message.reply( ticket.id + &amp;quot; has been created&amp;quot; )

bot = ServerBot.new

on_message( message ) = -&amp;gt;
  bot.dispatch( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets say that we had two different types of users, admins or not, and two different types of spaces, one that mapped to a project and another that mapped to a hangout area.  We could expand out idea of the SpaceDispatcher to return a different command object based upon the combinations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SpaceDispatcher &amp;lt; Dispatcher
  dispatch( message ) = -&amp;gt;
    space = find_space( message )
    user = find_user( message )
    if !space.project?
      if space.is_admin?( user )
        AdminLobbyResponder.new( space, user ).dispatch( message )
      else
        LobbyResponder.new( space, user ).dispatch( message )
    else if space.is_admin?( user )
      AdminSpaceResponder.new( space, user ).dispatch( message )
    else
      ProjectResponder.new( space, user ).dispatch( message )

class LobbyResponder &amp;lt; Dispatcher
  vote( message ) = -&amp;gt;
    votes = space.tally_term( message )
    message.reply( &amp;quot;That totals: &amp;quot; + votes )

class AdminLobbyResponder &amp;lt; LobbyResponder
  topic( message ) = -&amp;gt;
    space.set_topic( message )
    message.reply( &amp;quot;Topic updated&amp;quot; )

class ProjectResponder &amp;lt; LobbyResponder
  ticket( message ) = -&amp;gt;
    ticket = space.create_ticket( message )
    message.reply( ticket.id + &amp;quot; has been created&amp;quot; )

class AdminProjectResponder &amp;lt; ProjectResponder
  restart( message ) = -&amp;gt;
    restart_server
    message.reply( &amp;quot;Server restarted&amp;quot; )

bot = SpaceDispatcher.new

on_message( message ) = -&amp;gt;
  bot.dispatch( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#39;re also using inheritance to include all of the methods that the regular user can do into the class that has all of the Admin methods.  This pseudocode has turned into an unholey mixture of Ruby and CoffeeScript, so it probably isn&amp;#39;t work doing into language details with this.  But straight up inheritance doesn&amp;#39;t work well for this type of reuse, and in our example project admins won&amp;#39;t be able to change the &lt;code&gt;topic&lt;/code&gt;.  These commands would better be structured as mixins.&lt;/p&gt;

&lt;h2&gt;Conversationists&lt;/h2&gt;

&lt;p&gt;The final, and technically most complicated type of bot to write is a &lt;em&gt;Conversationalist&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reacts to messages&lt;/li&gt;
&lt;li&gt;Knows who they are talking to&lt;/li&gt;
&lt;li&gt;Can learn from what was said&lt;/li&gt;
&lt;li&gt;Has conversational state&lt;/li&gt;
&lt;li&gt;Knows where its being addressed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The basic structure is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Conversation &amp;lt; Dispatcher
  # knowledge collected during the course of the conversation #

  # state machine mapping conversion state #

  dispatch( message ) = -&amp;gt;
    # Store incoming message in log
    # interpret the response based upon the current state
    # print a message on state transition

class ChatBot &amp;lt; Dispatcher
  dispatch( message ) = -&amp;gt;
    user = find_user( message )
    conversation = user.current_conversation
    conversation.dispatch( message )

bot = ChatBot.new

on_message(message) = -&amp;gt;
  bot.dispatch( message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;User&lt;/code&gt; object is responsible for keeping track of conversations.  &lt;code&gt;current_conversation&lt;/code&gt; can be smart enough to create a new conversation when things are stale or if there user explicitly closed out an active one.&lt;/p&gt;

&lt;p&gt;Here is an example of code from a bot that asks you questions about where you are and what sort of food you are looking for.  It searches a number of APIs in the background to see what information it can get from what you say.  The code is written with an Adaptor to talk Twitter or GChat, and they both have a different idea of location.  Sometimes it can get an accurate enough location the message metadata, but more likely it&amp;#39;s too vague and it will ask you to clarify.  (&lt;em&gt;Not all of that logic is below, but its useful to demonstrate the use of the state machine&lt;/em&gt;.)&lt;/p&gt;

&lt;p&gt;The knowledge attributes are what the bot knows in the conversation.  Below you&amp;#39;ll see an example of &lt;em&gt;knowledge of the conversation&lt;/em&gt; from the state machine, &lt;em&gt;knowledge of what as been said&lt;/em&gt; from previous messages, and &lt;em&gt;knowledge of deduction&lt;/em&gt; from the content and context of the messages.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ConversationResponder
  # State Machine
  workflow do
    state :new do
      event :process_message,  :transitions_to =&amp;gt; :processing_location
    end

    state :processing_location do
      event :needs_location,    :transitions_to =&amp;gt; :clarify_location
      event :location_clear,    :transitions_to =&amp;gt; :has_location
    end

    state :clarify_location do
      event :process_message,   :transitions_to =&amp;gt; :processing_location
    end

    state :has_location do
      event :needs_keywords,    :transitions_to =&amp;gt; :clarify_keywords
      event :has_keywords,      :transitions_to =&amp;gt; :processing_keywords
    end

    state :clarify_keywords do
      event :process_message,   :transitions_to =&amp;gt; :processing_keywords
    end

    state :processing_keywords do
      event :needs_keywords,    :transitions_to =&amp;gt; :clarify_keywords
      event :needs_location,    :transitions_to =&amp;gt; :clarify_location
      event :found_places,      :transitions_to =&amp;gt; :refining_selection
      event :no_places_found,   :transitions_to =&amp;gt; :clarify_keywords
    end

    state :refining_selection do
      event :process_message,   :transitions_to =&amp;gt; :processing_keywords
    end
  end

  # Knowledge Attributes
  def looking_for_location?
    !knows_location? || location_vague?
  end

  def knows_location?
    !lat.blank? &amp;amp;&amp;amp; !lng.blank?
  end

  def location_vague?
    return false if location_range == &amp;quot;ROOFTOP&amp;quot; || location_range == &amp;quot;RANGE_INTERPOLATED&amp;quot;
    #Added by Jon so that zip codes are sufficient
    return false if location_range == &amp;quot;APPROXIMATE&amp;quot;
    #TODO: put more intelligence into this: eg location_range = &amp;quot;GEOMETRIC_CENTER&amp;quot; is good enough for Iowa but not for NYC
    true
  end

  def location_name
    if knows_location?
      status,address =  Geocode.reverse_geocode([lat,lng])
      return address
    else
      return nil
    end
  end

  def looking_for_places?
    places.count == 0
  end

  def have_keyword_messages?
    !keyword_messages.nil? &amp;amp;&amp;amp; keyword_messages.length &amp;gt; 0
  end

  def keyword_messages
    @keyword_messages ||= messages.select{ |x| x.looks_like_keyword? &amp;amp;&amp;amp; !x.is_a?( OutgoingMessage ) }
  end

  def keywords
    keyword_messages.collect { |x| x.search_terms }.join( &amp;quot;, &amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h2&gt;That&amp;#39;s the shape of it&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Notifiers&lt;/em&gt;, &lt;em&gt;Reactors&lt;/em&gt;, &lt;em&gt;Space Reactors&lt;/em&gt;, &lt;em&gt;Responders&lt;/em&gt;, &lt;em&gt;Space Responders&lt;/em&gt;, and &lt;em&gt;Conversationists&lt;/em&gt;.  Writing &lt;em&gt;Notifiers&lt;/em&gt; and &lt;em&gt;Reactors&lt;/em&gt; are more playful, and as you get into things later in the list you spend a lot more time dealing with code and logic complexity.&lt;/p&gt;

&lt;p&gt;The distinction between a &lt;em&gt;Spaced&lt;/em&gt; and &lt;em&gt;Global&lt;/em&gt; chat medium is something that makes using chat libraries, and building &lt;strong&gt;Adapters&lt;/strong&gt; to different services difficult.  If the library was built with a &lt;em&gt;Spaced&lt;/em&gt; service in mind it&amp;#39;s pretty straightforward to make it work for one, but going the other way isn&amp;#39;t swimming upstream.&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;Towards a taxonomy of Twitter Bots&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://tinysubversions.com/botsummit/2014/"&gt;BotSummit&lt;/a&gt; was a few days ago, and a bunch of people got together to talk about Twitter bots that they made largely as art projects.  Here&amp;#39;s a draft of a taxonomy of Twitter bots made by &lt;a href="https://twitter.com/tullyhansen"&gt;Tully Hanson&lt;/a&gt;.  In the parlance of this post, these are mainly &lt;em&gt;Notifiers&lt;/em&gt; and &lt;em&gt;Reactors&lt;/em&gt;, with some possible &lt;em&gt;Responders&lt;/em&gt; thrown in:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Twitter Bot Taxonomy" src="http://i.imgur.com/bKXNQ0V.png" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Here&amp;#39;s the &lt;a href="https://gist.github.com/tullyhansen/7621632"&gt;source document&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Notifiers&lt;/em&gt; are interesting not because of their technology, but because of what they actually do.  Here&amp;#39;s a &lt;a href="https://docs.google.com/document/d/1bka4o1RE9RPUeoUzgpTIKRWsgWHzZEKEADialnv7haQ/view"&gt;list of ideas that people came up with&lt;/a&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h1&gt;Agents of Note&lt;/h1&gt;

&lt;h2&gt;&lt;a href="https://hubot.github.com"&gt;Hubot from Github&lt;/a&gt; is a company chat bot, written in Node:&lt;/h2&gt;

&lt;p&gt;&lt;img alt="Silvrback blog image" src="https://silvrback.s3.amazonaws.com/uploads/5a2b7f44-c37b-4cfc-b0df-16e28a889160/HUBOT_large.jpg" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GitHub, Inc., wrote the first version of Hubot to automate our company chat room. Hubot knew how to deploy the site, automate a lot of tasks, and be a source of fun in the company. Eventually he grew to become a formidable force in GitHub. But he led a private, messy life. So we rewrote him.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Image from &lt;a href="https://hubot.github.com"&gt;Hubot site&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href="https://www.lita.io"&gt;Lita&lt;/a&gt; is similar to Hubot, but written in Ruby:&lt;/h2&gt;

&lt;p&gt;&lt;img alt="Silvrback blog image" src="https://silvrback.s3.amazonaws.com/uploads/a1895cd0-8429-4a82-9cd7-2b7557d3c0a3/lita-94f070fbb79e8ec62cc7a21ca39f8448_large.png" /&gt;
&lt;em&gt;Image from &lt;a href="https://www.lita.io"&gt;Lita&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href="https://github.com/cantino/huginn"&gt;Huginn&lt;/a&gt; is your agent, standing by&lt;/h2&gt;

&lt;p&gt;&lt;img alt="Silvrback blog image sb_float" src="https://silvrback.s3.amazonaws.com/uploads/4c8d7718-e8a1-4d6f-92b7-e2d1c92cec43/220px-Odin%2C_der_G%C3%B6ttervater_large.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Huginn takes a bit to install, but it&amp;#39;s a full on &lt;em&gt;software agent&lt;/em&gt; of the old school.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Huginn is a system for building agents that perform automated tasks for you online. They can read the web, watch for events, and take actions on your behalf. Huginn&amp;#39;s Agents create and consume events, propagating them along a directed graph. Think of it as a hackable Yahoo! Pipes plus IFTTT on your own server. You always know who has your data. You do.&lt;/p&gt;

&lt;p&gt;We&amp;#39;re just getting started, but here are some of the things that you can do with Huginn right now:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Track the weather and get an email when it&amp;#39;s going to rain (or snow) tomorrow (&amp;quot;Don&amp;#39;t forget your umbrella!&amp;quot;)&lt;/li&gt;
&lt;li&gt;List terms that you care about and receive emails when their occurrence on Twitter changes. (For example, want to know when something interesting has happened in the world of Machine Learning? Huginn will watch the term &amp;quot;machine learning&amp;quot; on Twitter and tell you when there is a large spike.)&lt;/li&gt;
&lt;li&gt;Watch for air travel or shopping deals&lt;/li&gt;
&lt;li&gt;Follow your project names on Twitter and get updates when people mention them&lt;/li&gt;
&lt;li&gt;Scrape websites and receive emails when they change&lt;/li&gt;
&lt;li&gt;Connect to Adioso, HipChat, Basecamp, Growl, FTP, IMAP, Jabber, JIRA, MQTT, nextbus, Pushbullet, Pushover, RSS, Bash, Slack, StubHub, translation APIs, Twilio, Twitter, Wunderground, and Weibo, to name a few.&lt;/li&gt;
&lt;li&gt;Compose digest emails about things you care about to be sent at specific times of the day&lt;/li&gt;
&lt;li&gt;Track counts of high frequency events and send an SMS within moments when they spike, such as the term &amp;quot;san francisco emergency&amp;quot;&lt;/li&gt;
&lt;li&gt;Send and receive WebHooks&lt;/li&gt;
&lt;li&gt;Run arbitrary JavaScript Agents on the server&lt;/li&gt;
&lt;li&gt;Track your location over time&lt;/li&gt;
&lt;li&gt;Create Amazon Mechanical Turk workflows as the inputs, or outputs, of agents. (&amp;quot;Once a day, ask 5 people for a funny cat photo; send the results to 5 more people to be rated; send the top-rated photo to 5 people for a funny caption; send to 5 final people to rate for funniest caption; finally, post the best captioned photo on my blog.&amp;quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Image &amp;quot;Odin, der GÃ¶ttervater&amp;quot; by Carl Emil Doepler (1824-1905) - WÃ¤gner, Wilhelm. 1882. Nordisch-germanische GÃ¶tter und Helden. Otto Spamer, Leipzig &amp;amp; Berlin. Page 7.. Licensed under Public domain via Wikimedia Commons - &lt;a href="http://commons.wikimedia.org/wiki/File:Odin,_der_G%C3%B6ttervater.jpg#mediaviewer/File:Odin,_der_G%C3%B6ttervater.jpg"&gt;Link&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Let me know cool things you build!&lt;/p&gt;
</content>
  </entry>
</feed>
