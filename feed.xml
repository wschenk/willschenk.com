<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blank Page Tech</title>
  <subtitle>Lets build things</subtitle>
  <id>http://willschenk.com/</id>
  <link href="http://willschenk.com/"/>
  <link href="http://willschenk.com/feed.xml" rel="self"/>
  <updated>2016-07-12T10:58:22-04:00</updated>
  <author>
    <name>Will Schenk</name>
  </author>
  <entry>
    <title>Deploying ActionCable on Heroku with Sidekiq</title>
    <link rel="alternate" href="http://willschenk.com/deploying-actioncable-on-heroku/"/>
    <id>http://willschenk.com/deploying-actioncable-on-heroku/</id>
    <published>2016-07-11T16:49:00-04:00</published>
    <updated>2016-07-11T16:49:00-04:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;ActionCable is WebSockets on rails.  This lets you create realtime, interactive systems, where you can push data from one client to another client without reloading or polling.  But how do we deploy it on heroku?&lt;/p&gt;

&lt;p&gt;ActionCable is composed to two main parts: a javascript client library, and a backend pub/sub system built upon Redis.  We&amp;#39;re also going to use ActiveJob to offload the publishing tasks from the main user thread, so we&amp;#39;ll also be setting up sidekiq.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s go through the steps of how to deploy things on heroku.&lt;/p&gt;

&lt;h2 id="first,-the-app"&gt;First, the app&lt;/h2&gt;

&lt;p&gt;I&amp;#39;m going to use an app that &lt;a href="https://medium.com/@dhh/rails-5-action-cable-demo-8bba4ccfc55e#.q92qfr3c2"&gt;dhh made as a walk through.&lt;/a&gt;  What it does is&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;creates a message model&lt;/li&gt;
&lt;li&gt;creates a rooms controller with a show action&lt;/li&gt;
&lt;li&gt;opens a websocket with the server&lt;/li&gt;
&lt;li&gt;that receives rendered messages on the &lt;code&gt;rooms_channel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and accepts messages to be broadcast to everyone else&lt;/li&gt;
&lt;li&gt;uses a background worker to render the message and broadcast it back to everyone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;#39;ve &lt;a href="https://github.com/HappyFunCorp/actioncable_chatapp/blob/master/README.md"&gt;transcribed it here&lt;/a&gt; to see what was added.  The code is available to &lt;a href="https://github.com/HappyFunCorp/actioncable_chatapp"&gt;clone the code from github&lt;/a&gt; if you don&amp;#39;t have an app that you are working on already.&lt;/p&gt;

&lt;h2 id="now-lets-talk-about-deployment"&gt;Now lets talk about deployment&lt;/h2&gt;

&lt;p&gt;The app we generated was done using basic rails 5 commands, and it&amp;#39;s out of the box stuff.  (Unlike most of the walkthroughs on this site which were done with &lt;a href="http://seed.happyfuncorp.com"&gt;seed&lt;/a&gt;.  It&amp;#39;s setup to use puma (good), which will handle the WebSockets.  It&amp;#39;s also setup with ActiveJob and ActionCable, both on which are in async local mode and won&amp;#39;t use redis in development.  ActionCable will also need to know where it&amp;#39;s websocket is going to connect to. Lets walk through everything that needs to get done.&lt;/p&gt;

&lt;h2 id="gemfile"&gt;Gemfile&lt;/h2&gt;

&lt;p&gt;First we need to add some things to the Gemfile, specifically redis, postgres, and the sidekiq gems.  Add the following to your &lt;code&gt;Gemfile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;#39;redis&amp;#39;, &amp;#39;~&amp;gt; 3.0&amp;#39;
gem &amp;#39;pg&amp;#39;, group: :production
gem &amp;#39;sqlite3&amp;#39;, group: :development
gem &amp;#39;sidekiq&amp;#39;
gem &amp;#39;sinatra&amp;#39;, git: &amp;#39;https://github.com/sinatra/sinatra&amp;#39;, :require =&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you remove the &lt;code&gt;sqlite3&lt;/code&gt; on the top of the file, we only want it in development.  We are installing &lt;code&gt;sinatra&lt;/code&gt; out of the master branch since the current release doesn&amp;#39;t play well with Rails 5.  (If it tries to install Sinatra 1.0 you&amp;#39;ll get rake exception errors.)  If you don&amp;#39;t want the web interface to sidekiq you can omit.&lt;/p&gt;

&lt;h2 id="setup-sidekiq"&gt;Setup sidekiq&lt;/h2&gt;

&lt;p&gt;First we need to create a &lt;code&gt;Procfile&lt;/code&gt; that defines our dynos&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web: bundle exec puma -C config/puma.rb
worker: bundle exec sidekiq -c 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;m running sidekiq with a concurrency of 2 to limit the number of redis connections.  You&amp;#39;ll probably want that a lot higher in real life if you are using Sidekiq for other things..&lt;/p&gt;

&lt;p&gt;Now create &lt;code&gt;config/initializers/active_job.rb&lt;/code&gt; and tell ActiveJob to use &lt;code&gt;sidekiq&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;Rails.application.config.active_job.queue_adapter = :sidekiq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And let&amp;#39;s add the sidekiq web interace to your &lt;code&gt;config/routes.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  require &amp;#39;sidekiq/web&amp;#39;
  mount Sidekiq::Web =&amp;gt; &amp;#39;/sidekiq&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this was a real app, you&amp;#39;d limit who can get to that engine.  If you installed devise, the way to do that is:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  authenticate :admin_user do
    mount Sidekiq::Web =&amp;gt; &amp;#39;/sidekiq&amp;#39;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="a-brief-digression-to-test-locally"&gt;A brief digression to test locally&lt;/h2&gt;

&lt;p&gt;It&amp;#39;s always nice to change as little as we can, so when everything blows up in our face we can limit our investigations to a small change set.  So lets first migrate our development environment to communicate over redis, so the ActiveJobs are run in a seperate process, and that ActionCable will be able to communicate from that process, back to the main web server, back to the client.&lt;/p&gt;

&lt;p&gt;Edit &lt;code&gt;config/cable.yml&lt;/code&gt; to set the development environment use to use redis.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;development:
  adapter: redis
  url: redis://localhost:6379/1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;#39;t have redis installed, use &lt;a href="http://brew.sh"&gt;homebrew&lt;/a&gt; to do that now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install redis
$ redis-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;#39;t have foreman installed, do that now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install foreman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets run that app!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails db:migrate
$ foreman start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using foreman will start both the web interace as well as the sidekiq worker.&lt;/p&gt;

&lt;p&gt;Now you should be able to go to &lt;code&gt;http://localhost:3000&lt;/code&gt; in multiple windows and talk with yourself.  I really like talking with myself, and I assume that you do as well.&lt;/p&gt;

&lt;p&gt;And &lt;code&gt;http://localhost:3000/admin&lt;/code&gt; should load up the sidekiq admin console.  Validate that everything is working, since now we are going to spin up everything on heroku!&lt;/p&gt;

&lt;h2 id="heroku-and-redis"&gt;Heroku and Redis&lt;/h2&gt;

&lt;p&gt;Create a new app:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we create a redis instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku addons:create heroku-redis:hobby-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now need to tell ActionCable where it&amp;#39;s redis server is.  Lets find out the answer and put in into the production section of &lt;code&gt;config/cable.yml&lt;/code&gt;. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  heroku config | grep REDIS
REDIS_URL:                redis://h:p75fl9as.........
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config/cable.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;production:
  adapter: redis
  url: redis://h:p75fl9as.........
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="set-the-right-actioncable-websocket-address"&gt;Set the right ActionCable websocket address&lt;/h2&gt;

&lt;p&gt;We need to tell rails where it&amp;#39;s expected to receive the websocket connection from. &lt;code&gt;heroku info&lt;/code&gt; will show us our external application.  If you deploy on a custom url, you&amp;#39;ll need to add that as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku info
=== aqueous-thicket-49913
Addons:        heroku-postgresql:hobby-dev
               heroku-redis:hobby-dev
Dynos:         web: 1, worker: 1
Git URL:       https://git.heroku.com/aqueous-thicket-49913.git
Owner:         operations@happyfuncorp.com
Region:        us
Repo Size:     34 KB
Slug Size:     29 MB
Stack:         cedar-14
Web URL:       https://aqueous-thicket-49913.herokuapp.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets tell rails about it.  Edit &lt;code&gt;config/environments/production.rb&lt;/code&gt;.  Obviously update the urls for your application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  config.action_cable.url = &amp;#39;wss://aqueous-thicket-49913.herokuapp.com/cable&amp;#39;
  config.action_cable.allowed_request_origins = [ &amp;#39;https://aqueous-thicket-49913.herokuapp.com&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;wss&lt;/code&gt; is WebSockets over over SSL.  You should use that, for a number of reasons including but not limited to security.  However, if you don&amp;#39;t use SSL, use &lt;code&gt;ws&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;Now we need to tell the javascript where to connect.  Lets open up &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; and add this into the &lt;code&gt;&amp;lt;HEAD&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;%= action_cable_meta_tag %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="commit-and-push"&gt;Commit and push&lt;/h2&gt;

&lt;p&gt;First we add the code to repo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -a -m &amp;quot;Added heroku configuration&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we push to heroku itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If that goes well, lets create the database tables and spin up the worker process&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku run rake db:migrate
$ heroku ps:scale worker=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, lets run the app and look at the logs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku open
$ heroku open
$ heroku log --tail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We ran open twice, so you could see what was there in two windows.  Does it work?  Do 3 windows work?&lt;/p&gt;

&lt;p&gt;Do you like talking to yourself as much as I do?&lt;/p&gt;

&lt;h2 id="but-does-it-scale"&gt;But does it scale&lt;/h2&gt;

&lt;p&gt;Right now you have 1 web dyno, running puma with 5 threads, and 1 worker dyno running sidekiq with 2 concurrent worker.  This should be at least 5 redis connections, up to 2 more depending upon how many jobs have gone through sidekiq.  Lets look at the redis info:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku redis:cli
ec2-54-243-230-243.compute-1.amazonaws.com:24949&amp;gt; info

....
# Clients
connected_clients:7
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:2
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we see that we have 7 active connections now.  As you get more people listening to redis, those will go up.  Adding more dynos will push the number of active connections up, so you need to be careful in sizing both your postgres install as well as your redis install.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Image credit &lt;a href="https://www.flickr.com/photos/flintman45/15521201146/in/photolist-pDydmj-4EmYXp-5iGRcG-4KrLFJ-rjnz22-9Cpo2C-azDiP-adi58f-aSgSYP-7Uc2y7-bmGghk-a4pD4T-5wDbbf-a3zri3-7rDRMh-9Z3c6a-471ZjP-8qQ2fX-kYdZ28-9Z6fc9-9ap1TR-2nhNUA-93VFQa-76jVr-4Q3WXY-bbVhbt-9Z3ij2-kx5BP4-59LXDM-nnav37-eTfHYC-p3JqVp-k6dTdF-qxURpr-ay5db9-5vk21b-oC9hPd-n4bS2m-476583-pMvQCn-CffNFE-rbndpL-6QP35H-d1mxVf-9Wrx53-a1LCGS-d1mxZJ-9ugrWA-9XFZPm-46WZVf"&gt;Lee Roberts&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Inflight internet</title>
    <link rel="alternate" href="http://willschenk.com/inflight-internet/"/>
    <id>http://willschenk.com/inflight-internet/</id>
    <published>2015-12-18T10:13:00-05:00</published>
    <updated>2015-12-18T10:13:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Say you are two people on a plane who need access to internet.  A flight pass costs $9.95, so that would be $19.90 for both.  Here&amp;#39;s how to get it for $8.95 instead:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fire up the iOS simulator.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="row"&gt;&lt;div class="col-sm-4 col-xs-8"&gt;&lt;img src="images/wifi/simulator-233ceba2.jpg" /&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Use the simulator to sign up for the mobile price of $8.95, rather than the computer price of $9.95.  Since you are signing up on your computer, once you have access the whole machine has access.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Turn on Internet Sharing over bluetooth in system preferences&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="row"&gt;&lt;div class="col-sm-8"&gt;&lt;img src="images/wifi/sharing-8799b7fd.jpg" /&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Make your computer discoverable over bluetooth by opening up the blue tooth preferences:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="row"&gt;&lt;div class="col-sm-8"&gt;&lt;img src="images/wifi/bluetooth-59182088.jpg" /&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;On the second computer, turn &lt;em&gt;off&lt;/em&gt; wifi and turn &lt;em&gt;on&lt;/em&gt; bluetooth.  Connect to the first computer using bluetooth.  The first computer will ask if you want to pair, and say yes.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Once it&amp;#39;s connected, on the second computer say &amp;quot;Connect to Network&amp;quot; in the bluetooth menu.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now you email in the sky.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Using seed to explore APIs</title>
    <link rel="alternate" href="http://willschenk.com/using-seed-to-explore/"/>
    <id>http://willschenk.com/using-seed-to-explore/</id>
    <published>2015-09-17T10:21:00-04:00</published>
    <updated>2015-09-17T10:21:00-04:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;#39;ve been working to update seed, which is HappyFunCorp&amp;#39;s app generator to make it easy to kick off MVPs.  Check out the website for more information.  One of the things that I&amp;#39;ve started to do is to seperate out the dependancies more, and being tutorials on how to use each of the different features.  After I link to that stuff, let&amp;#39;s walk through a way to combine different techniques we&amp;#39;ve discussed together.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Check out &lt;a href="http://seed.happyfuncorp.com"&gt;the site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Or watch the video:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="embed-responsive embed-responsive-16by9"&gt;
  &lt;iframe src="https://www.youtube.com/embed/hCsPDaKHw6I?rel=0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id="the-basic-process"&gt;The basic process&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Get access to the API.&lt;/li&gt;
&lt;li&gt;Open up a console and start playing with commands.&lt;/li&gt;
&lt;li&gt;Start storing the data locally once we need to get more.&lt;/li&gt;
&lt;li&gt;Play around with the data.&lt;/li&gt;
&lt;li&gt;Design a UI around in.&lt;/li&gt;
&lt;li&gt;Refactor the test &amp;quot;scripts&amp;quot; into ruby classes that fit that UI.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="using-seed,-oauth,-and-rake-to-explore-github-data"&gt;Using Seed, OAuth, and Rake to explore github data&lt;/h2&gt;

&lt;p&gt;What I want to do is to look at all of the &lt;code&gt;Gemfile&lt;/code&gt;s for all of our projects, and see which gems are the most popular, which versions we are using, and if we can develop some more expertise around it.  But first, I want to get the data.&lt;/p&gt;

&lt;p&gt;I could go to each of the repos in github, but there are well over a hundred so that doesn&amp;#39;t work.  Github has an API, which is great, but I need oauth2 to access it.  Let&amp;#39;s get going.&lt;/p&gt;

&lt;h2 id="creating-a-github-application"&gt;Creating a github application&lt;/h2&gt;

&lt;p&gt;The first step is to make sure you have a github application. &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Go to &lt;a href="https://github.com/settings/developers"&gt;developer applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Click &lt;em&gt;Register New Application&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Enter in &lt;code&gt;http://localhost:3000/users/auth/github/callback&lt;/code&gt; as the callback URL.&lt;/li&gt;
&lt;li&gt;Fill in whatever else.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Resister the Application&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point you should have the &lt;em&gt;Client ID&lt;/em&gt; and the &lt;em&gt;Client Secret&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id="create-a-seed_defaults-file"&gt;Create a seed_defaults file&lt;/h2&gt;

&lt;p&gt;Once I create a remote app, I like to put the credentials into the &lt;code&gt;~/.seed_defaults&lt;/code&gt; file.  This will make it so the next time I generate a seed app, these are the default credentials that are used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GITHUB_APP_ID=replace with client id
GITHUB_APP_SECRET=replace with client secret
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="generate-the-app"&gt;Generate the app&lt;/h2&gt;

&lt;p&gt;If you haven&amp;#39;t installed &lt;a href="http://seed.happyfuncorp.com"&gt;happy_seed&lt;/a&gt; yet, do so now by typing &lt;code&gt;gem install happy_seed&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then generate the app:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ happy_seed rails project_stats
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;#39;s going to install things.  Inititally, just say no to everything.  Once it&amp;#39;s done, install the github generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd project_status
$ rails g happy_seed:github
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That will do its thing.  Then we need to create the database and get going:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="ask-for-more-scope"&gt;Ask for more scope&lt;/h2&gt;

&lt;p&gt;When the &lt;em&gt;github&lt;/em&gt; generator is run, it configures the oauth scope that it requests in &lt;code&gt;config/initializers/devise.rb&lt;/code&gt;.  We need to ask for a bit more permissions, so open up that file and change the scope requested to be &lt;code&gt;&amp;quot;user,repo,read:org&amp;quot;&lt;/code&gt;, so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.omniauth :github, ENV[&amp;#39;GITHUB_APP_ID&amp;#39;], ENV[&amp;#39;GITHUB_APP_SECRET&amp;#39;], scope: &amp;quot;user,repo,read:org&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets start the server and see what&amp;#39;s up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails s
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Point your browser to &lt;a href="http://localhost:3000"&gt;http://localhost:3000&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Select &amp;quot;Sign up&amp;quot; from the &amp;quot;Account&amp;quot; menu.&lt;/li&gt;
&lt;li&gt;Press &amp;quot;Sign in with Github&amp;quot;&lt;/li&gt;
&lt;li&gt;You should be bounced to github and you have to accept.&lt;/li&gt;
&lt;li&gt;You should be back on localhost with the message &lt;code&gt;Successfully authenticated from Github account.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="lets-play"&gt;Lets play&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Get access to the API.&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;Open up a console and start playing with commands.&lt;/li&gt;
&lt;li&gt;Start storing the data locally once we need to get more.&lt;/li&gt;
&lt;li&gt;Play around with the data.&lt;/li&gt;
&lt;li&gt;Design a UI around in.&lt;/li&gt;
&lt;li&gt;Refactor the test &amp;quot;scripts&amp;quot; into ruby classes that fit that UI.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lets get in that console and see what we can do.  If you look at &lt;code&gt;app/models/user.rb&lt;/code&gt; you can see that there&amp;#39;s code to setup the github client, and we can access it like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails c
Loading development environment (Rails 4.2.3)
2.2.1 :001 &amp;gt; gc = User.first.github_client
  User Load (0.2ms)  SELECT  &amp;quot;users&amp;quot;.* FROM &amp;quot;users&amp;quot;  ORDER BY &amp;quot;users&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1
  User Load (0.2ms)  SELECT  &amp;quot;users&amp;quot;.* FROM &amp;quot;users&amp;quot;  ORDER BY &amp;quot;users&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1
  Identity Load (0.4ms)  SELECT  &amp;quot;identities&amp;quot;.* FROM &amp;quot;identities&amp;quot; WHERE &amp;quot;identities&amp;quot;.&amp;quot;user_id&amp;quot; = ? AND &amp;quot;identities&amp;quot;.&amp;quot;provider&amp;quot; = ?  ORDER BY &amp;quot;identities&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1  [[&amp;quot;user_id&amp;quot;, 1], [&amp;quot;provider&amp;quot;, &amp;quot;github&amp;quot;]]
  Identity Load (0.4ms)  SELECT  &amp;quot;identities&amp;quot;.* FROM &amp;quot;identities&amp;quot; WHERE &amp;quot;identities&amp;quot;.&amp;quot;user_id&amp;quot; = ? AND &amp;quot;identities&amp;quot;.&amp;quot;provider&amp;quot; = ?  ORDER BY &amp;quot;identities&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1  [[&amp;quot;user_id&amp;quot;, 1], [&amp;quot;provider&amp;quot;, &amp;quot;github&amp;quot;]]
 =&amp;gt; #&amp;lt;Octokit::Client:0x007fe1f7bec7e8 

2.2.1 :002 &amp;gt; gc.org_repos( &amp;#39;HappyFunCorp&amp;#39;, {:type =&amp;gt; &amp;#39;private&amp;#39;} ).count
 =&amp;gt; 30 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, now we can start figuring out what we need to do to get access to the data.  We have an authenticated user account, and we can start hitting the API.  I know for a fact that I have way more than 30 repos -- I mean, seriously -- so first thing is to figure out why that is and how to get more.  It&amp;#39;s probably related to pagination.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.2.1 :003 &amp;gt; gc.org_repos( &amp;#39;HappyFunCorp&amp;#39;, {:type =&amp;gt; &amp;#39;private&amp;#39;, per_page: 100} ).count
 =&amp;gt; 100 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, looking through the &lt;a href="https://github.com/octokit/octokit.rb/issues/255"&gt;octokit issues&lt;/a&gt; this can be dealt with by turning &lt;code&gt;auto_paginate: true&lt;/code&gt; on when we load up the client.  So let&amp;#39;s edit &lt;code&gt;app/models/user.rb&lt;/code&gt; to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@github_client ||= Octokit::Client.new(access_token: github.accesstoken, auto_paginate: true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back to the console, do &lt;code&gt;reload!&lt;/code&gt; and load up our client again.  Notice that I&amp;#39;m making this a one liner, since we&amp;#39;re going to be doing it over and over its nice to use the arrow keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.2.1 :004 &amp;gt; reload!; gc = User.first.github_client
Reloading...
  User Load (0.1ms)  SELECT  &amp;quot;users&amp;quot;.* FROM &amp;quot;users&amp;quot;  ORDER BY &amp;quot;users&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1
  User Load (0.1ms)  SELECT  &amp;quot;users&amp;quot;.* FROM &amp;quot;users&amp;quot;  ORDER BY &amp;quot;users&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1
  Identity Load (0.2ms)  SELECT  &amp;quot;identities&amp;quot;.* FROM &amp;quot;identities&amp;quot; WHERE &amp;quot;identities&amp;quot;.&amp;quot;user_id&amp;quot; = ? AND &amp;quot;identities&amp;quot;.&amp;quot;provider&amp;quot; = ?  ORDER BY &amp;quot;identities&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1  [[&amp;quot;user_id&amp;quot;, 1], [&amp;quot;provider&amp;quot;, &amp;quot;github&amp;quot;]]
  Identity Load (0.2ms)  SELECT  &amp;quot;identities&amp;quot;.* FROM &amp;quot;identities&amp;quot; WHERE &amp;quot;identities&amp;quot;.&amp;quot;user_id&amp;quot; = ? AND &amp;quot;identities&amp;quot;.&amp;quot;provider&amp;quot; = ?  ORDER BY &amp;quot;identities&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1  [[&amp;quot;user_id&amp;quot;, 1], [&amp;quot;provider&amp;quot;, &amp;quot;github&amp;quot;]]
 =&amp;gt; #&amp;lt;Octokit::Client:0x007fe1f7d986f0 @access_token=&amp;quot;*.......

2.2.1 :005 &amp;gt; gc.org_repos( &amp;#39;HappyFunCorp&amp;#39;, {:type =&amp;gt; &amp;#39;private&amp;#39;} ).count
 =&amp;gt; 169 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, that looks better.  That will give us a list of all the repos, so now we just need to see how to get the contents of our file, and then we can put it all together.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.2.1 :006 &amp;gt; repo = gc.org_repos( &amp;#39;HappyFunCorp&amp;#39;, {:type =&amp;gt; &amp;#39;private&amp;#39;} ).first
 =&amp;gt; {:id=&amp;gt;988713,
 :name=&amp;gt;&amp;quot;benchcoach&amp;quot;,
 :full_name=&amp;gt;&amp;quot;HappyFunCorp/benchcoach&amp;quot;,
 :owner=&amp;gt;
 .....

2.2.1 :007 &amp;gt; repo.full_name
 =&amp;gt; &amp;quot;HappyFunCorp/benchcoach&amp;quot; 

2.2.1 :008 &amp;gt; content = gc.contents repo.full_name, path: &amp;#39;Gemfile&amp;#39;
 =&amp;gt; {:name=&amp;gt;&amp;quot;Gemfile&amp;quot;,
 :path=&amp;gt;&amp;quot;Gemfile&amp;quot;,
 :sha=&amp;gt;&amp;quot;1d67bb85e43adab5b68ecc0eb3a5304e6ee2588e&amp;quot;,....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at this, we see that github returns the contents of the file base64 encoded.  I guess that makes sense, so if we want to print it out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.2.1 :009 &amp;gt; Base64.decode64 content.content
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="using-rake-to-pull-the-data-down"&gt;Using Rake to pull the data down&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Get access to the API.&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Open up a console and start playing with commands.&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;Start storing the data locally once we need to get more.&lt;/li&gt;
&lt;li&gt;Play around with the data.&lt;/li&gt;
&lt;li&gt;Design a UI around in.&lt;/li&gt;
&lt;li&gt;Refactor the test &amp;quot;scripts&amp;quot; into ruby classes that fit that UI.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lets use rake to start managing the data.  We&amp;#39;re going to be using some of the techniques that were outlined in the &lt;a href="/using-rake-for-dataflow-programming-and-data-science/]"&gt;using rake for dataflow programming and data science&lt;/a&gt; post.  First step is to create a &lt;code&gt;lib/tasks/github.rake&lt;/code&gt; file that we&amp;#39;re going to put our tasks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;fileutils&amp;#39;

file &amp;quot;data/projects.json&amp;quot; do
  Rake::Task[&amp;quot;environment&amp;quot;].invoke
  FileUtils.mkdir_p &amp;quot;data&amp;quot;

  gc = User.first.github_client

  data = gc.org_repos( &amp;#39;HappyFunCorp&amp;#39;, {:type =&amp;gt; &amp;#39;private&amp;#39;} ).collect do |x|
    { name: x[:name],
      full_name: x[:full_name],
      url: x[:url] }
  end

  File.open( &amp;quot;data/projects.json&amp;quot;, &amp;quot;w&amp;quot; ) do |out|
    out.puts JSON.unparse( data )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Be sure to change the &lt;code&gt;HappyFunCorp&lt;/code&gt; to your organization, or use the &lt;code&gt;repos&lt;/code&gt; call instead of the organization one.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now lets run &lt;code&gt;rake data/projects.json&lt;/code&gt;.  If you run it a second time, notice that rake returns imediately and doesn&amp;#39;t hit the remote server.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;file&lt;/code&gt; task only runs if the file doesn&amp;#39;t exist.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rake::Task[&amp;quot;environment&amp;quot;].invoke&lt;/code&gt; is a way to ensure that a task as been run without forcing it to run.&lt;/li&gt;
&lt;li&gt;The API calls are from our console experiments.&lt;/li&gt;
&lt;li&gt;Just save it to a file.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OK, now lets be able to loop over everything to load the files that we want.  First we define a method that lets us define a task to loop over all the entries in a JSON array, and then we&amp;#39;ll call it with our block which loads up the contents.  (Add this to the end of the &lt;code&gt;github.rake&lt;/code&gt; file)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def for_each_elem( name, file )
  task name =&amp;gt; file do
    JSON.parse( File.read( file ) ).each do |record|
      yield record
    end
  end
end

for_each_elem &amp;quot;load_gemfiles&amp;quot;, &amp;quot;data/projects.json&amp;quot; do |repo|
  outfile = &amp;quot;data/gemfiles/#{repo[&amp;#39;name&amp;#39;]}.Gemfile.lock&amp;quot;
  FileUtils.mkdir_p &amp;quot;data/gemfiles&amp;quot;

  file outfile do
    Rake::Task[&amp;quot;environment&amp;quot;].invoke

    gc = User.first.github_client

    begin
      content = gc.contents repo[&amp;#39;full_name&amp;#39;], path: &amp;#39;Gemfile.lock&amp;#39;

      File.open outfile, &amp;quot;w&amp;quot; do |out|
        out.puts Base64.decode64 content.content
      end
    rescue Octokit::NotFound
      puts &amp;quot;No Gemfile.lock found for #{repo[&amp;#39;full_name&amp;#39;]}&amp;quot;
    end
  end

  Rake::Task[outfile].invoke
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run it, &lt;code&gt;rake load_gemfiles&lt;/code&gt;.  Depending upon how many repos you have, this could take a few seconds.  (Also make sure you&amp;#39;ve updated the organization!)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Define a file task for each output file, that we will &lt;code&gt;invoke&lt;/code&gt; at the very end.&lt;/li&gt;
&lt;li&gt;Inside the task, make sure that the &lt;code&gt;environment&lt;/code&gt; is loaded.&lt;/li&gt;
&lt;li&gt;Pull down the contents of the Gemfile.lock from the API.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you run this a second time, notice that it only attempts to load from the files that weren&amp;#39;t loaded before.&lt;/p&gt;

&lt;p&gt;For fun, delete the &lt;code&gt;data&lt;/code&gt; directly and run the rake task again.  BOOM!&lt;/p&gt;

&lt;h2 id="massaging-the-data-into-something-usable"&gt;Massaging the data into something usable&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Get access to the API.&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Open up a console and start playing with commands.&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Start storing the data locally once we need to get more.&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;Play around with the data.&lt;/li&gt;
&lt;li&gt;Design a UI around in.&lt;/li&gt;
&lt;li&gt;Refactor the test &amp;quot;scripts&amp;quot; into ruby classes that fit that UI.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OK, now that we have all the data, lets figure out how to slice and dice it.  Lets just wire together some standard UNIX tools to filter and get some info.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for_each_elem &amp;quot;filter_gemfiles&amp;quot;, &amp;quot;data/projects.json&amp;quot; do |repo|
  sourcefile = &amp;quot;data/gemfiles/#{repo[&amp;#39;name&amp;#39;]}.Gemfile.lock&amp;quot;
  outfile = &amp;quot;data/filtered/#{repo[&amp;#39;name&amp;#39;]}.gems&amp;quot;
  FileUtils.mkdir_p &amp;quot;data/filtered&amp;quot;

  if File.exists?( sourcefile )
    file outfile do
      system( &amp;quot;awk &amp;#39;/^    [^ ]/ { print $1, $2 }&amp;#39; #{sourcefile} &amp;gt; #{outfile}&amp;quot; )
    end
    Rake::Task[outfile].invoke
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;code&gt;rake filter_gemfiles&lt;/code&gt; will go through and only show the specific gems that were locked out the Gemfile.locks.  Obviously, filtering the file based on the fact that it has exactly 4 spaces isn&amp;#39;t robust, but it works.&lt;/p&gt;

&lt;p&gt;Lets add a couple of other nifty methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file &amp;quot;data/versioned.list&amp;quot; do
  system( &amp;quot;cat data/filtered/* | sort | uniq -c | sort -rn &amp;gt; data/versioned.list&amp;quot; )
end

file &amp;quot;data/gems.list&amp;quot; do
  system( &amp;quot;awk &amp;#39;{print $1}&amp;#39; data/filtered/* | sort | uniq -c | sort -rn &amp;gt; data/gems.list&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;m going to stop here, but in case you are wondering the top gems that we use are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;(82) json&lt;/li&gt;
&lt;li&gt;(81) tzinfo&lt;/li&gt;
&lt;li&gt;(81) i18n&lt;/li&gt;
&lt;li&gt;(81) activesupport&lt;/li&gt;
&lt;li&gt;(79) rack&lt;/li&gt;
&lt;li&gt;(79) multi_json&lt;/li&gt;
&lt;li&gt;(78) sass&lt;/li&gt;
&lt;li&gt;(77) rack-test&lt;/li&gt;
&lt;li&gt;(76) tilt&lt;/li&gt;
&lt;li&gt;(76) mime-types&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="repeatable-data-in-10-minutes"&gt;Repeatable data in 10 minutes&lt;/h2&gt;

&lt;p&gt;There&amp;#39;s lots of stuff you can do from there, the most likely one being &amp;quot;sending an email and forgetting about it.&amp;quot;  But lets look at what we have.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The access key isn&amp;#39;t hard coded anywhere.  When you come back to this, if it expires, you just reconnect on the website.&lt;/li&gt;
&lt;li&gt;Way easier to get access keys this way, only a few oauth providers make this simple.  (Twitter does, for example, github doesn&amp;#39;t.)&lt;/li&gt;
&lt;li&gt;There&amp;#39;s a direct process transitioning from &amp;#39;playing around&amp;#39; to automated.&lt;/li&gt;
&lt;li&gt;Loading the data from the remote API is automated and repeatable.  If you&amp;#39;ve setup the dependancies correctly, you can run the rake tasks and things magically get up to date.&lt;/li&gt;
&lt;li&gt;If you do want to build a UI around this, you already have a webapp up and running...&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Importantly, this is something that you can get up and going with in under 10 minutes, at least if you know how the API works.  It takes less that 1 minute to get to the point where you have an authenticated client to the remote service and you can spend time exploring.&lt;/p&gt;

&lt;p&gt;One of the reasons I like having seed around to help prototype and explore ideas!&lt;/p&gt;

&lt;p&gt;Source code can be found: &lt;a href="https://github.com/wschenk/project_stats_demo"&gt;https://github.com/wschenk/project_stats_demo&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Building a GUI for managing middleman blogs</title>
    <link rel="alternate" href="http://willschenk.com/building-a-gui-for-managing-middleman-blogs/"/>
    <id>http://willschenk.com/building-a-gui-for-managing-middleman-blogs/</id>
    <published>2015-07-29T20:00:00-04:00</published>
    <updated>2015-07-29T20:00:00-04:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Can we make static site generators work like a normal site? Lets take a look at how we&amp;#39;d start to implement &lt;a href="/slow-data-and-fast-sites/"&gt;Slow Data and Fast Sites&lt;/a&gt; using the example of building an admin UI for a Middleman blog.&lt;/p&gt;

&lt;h2 id="tldr"&gt;TLDR&lt;/h2&gt;

&lt;p&gt;Given a middleman app with &lt;code&gt;middleman-blog&lt;/code&gt; and &lt;code&gt;middleman-blog-drafts&lt;/code&gt; configured:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add &lt;code&gt;middleman-blog-ui&lt;/code&gt; in your &lt;code&gt;Gemfile&lt;/code&gt;.  &lt;em&gt;This document describes how &lt;code&gt;middleman-blog-ui&lt;/code&gt; works.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Add &lt;code&gt;activate :blog_ui&lt;/code&gt; in &lt;code&gt;config.rb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start &lt;code&gt;middleman server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Visit &lt;a href="http://localhost:4567/admin"&gt;http://localhost:4567/admin&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And now you are living in the fabulous world where you can, from your browser:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Edit existing drafts and posts&lt;/li&gt;
&lt;li&gt;Create new drafts&lt;/li&gt;
&lt;li&gt;Publish drafts into posts&lt;/li&gt;
&lt;li&gt;Run some basic &lt;code&gt;git&lt;/code&gt; commands.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;middleman build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;middleman deploy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="why-do-this"&gt;Why do this&lt;/h2&gt;

&lt;p&gt;This is explained in more detail in the  &lt;a href="/slow-data-and-fast-sites/"&gt;Slow Data and Fast Sites&lt;/a&gt; post, but basically what we&amp;#39;re trying to do it seperate out runtime tooling with development time tooling.  &lt;em&gt;Future work will be around differentiating when components are rendered and from which data source.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Static sites have a huge runtime benefit, but actually setting them up and running them can &lt;a href="http://veekaybee.github.io/static-sites-suck/"&gt;really suck unless you already know how to do it&lt;/a&gt;.  This is a proof of concept of how to add a CMS to a static site so that it&amp;#39;s easier to manage.  This doesn&amp;#39;t address the &amp;quot;pain in the ass to setup&amp;quot; part, but it helps with the usability.&lt;/p&gt;

&lt;p&gt;Lets walk through what we&amp;#39;re doing if we were to implement this in your own app directly.  The gem packages this up with a slightly different directory scheme, but the code below is the same but slightly easier to understand.&lt;/p&gt;

&lt;h2 id="the-basic-idea"&gt;The basic idea&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re going to add a static JavaScript application in the &lt;code&gt;source/admin&lt;/code&gt; directory which will interact with the local filesystem and middleman install.  This application will consume data from your middleman app on the local system, in the &amp;quot;development&amp;quot; environment, such as the lists of published and draft articles, and will interact with a API server that will be mounted as part of the middleman preview server.  This will allow the Javascript app to change the filesystem, which will in turn be monitored and rendered by the middleman application.  &lt;/p&gt;

&lt;p&gt;Examples of the commands that can be triggered are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create new draft&lt;/li&gt;
&lt;li&gt;publish draft into article&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bundle exec middleman build&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;svg width="255pt" height="260pt" viewBox="0.00 0.00 255.34 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)"&gt;&lt;title&gt;G&lt;/title&gt;&lt;polygon fill="white" stroke="none" points="-4,4 -4,-256 251.341,-256 251.341,4 -4,4"/&gt;&amp;lt;!-- app --&amp;gt;&lt;g id="node1" class="node"&gt;&lt;title&gt;app&lt;/title&gt;&lt;polygon fill="none" stroke="black" points="142.136,-252 0.722016,-252 0.722016,-216 142.136,-216 142.136,-252"/&gt;&lt;text text-anchor="middle" x="71.4292" y="-229.8" font-family="Times,serif" font-size="14.00"&gt;Static Middleman Site&lt;/text&gt;&lt;/g&gt;&amp;lt;!-- admin --&amp;gt;&lt;g id="node2" class="node"&gt;&lt;title&gt;admin&lt;/title&gt;&lt;polygon fill="none" stroke="black" points="154.788,-36 0.0707361,-36 0.0707361,-0 154.788,-0 154.788,-36"/&gt;&lt;text text-anchor="middle" x="77.4292" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;Admin JS FrontEnd App&lt;/text&gt;&lt;/g&gt;&amp;lt;!-- admin&amp;#45;&amp;gt;app --&amp;gt;&lt;g id="edge5" class="edge"&gt;&lt;title&gt;admin&amp;#45;&amp;gt;app&lt;/title&gt;&lt;path fill="none" stroke="black" d="M66.8041,-36.444C61.3313,-46.4566 55.2313,-59.4912 52.4292,-72 42.0373,-118.39 53.6295,-173.651 62.7198,-205.883"/&gt;&lt;polygon fill="black" stroke="black" points="59.4841,-207.285 65.6713,-215.885 66.1979,-205.303 59.4841,-207.285"/&gt;&lt;/g&gt;&amp;lt;!-- api --&amp;gt;&lt;g id="node3" class="node"&gt;&lt;title&gt;api&lt;/title&gt;&lt;polygon fill="none" stroke="black" points="181.916,-108 60.9429,-108 60.9429,-72 181.916,-72 181.916,-108"/&gt;&lt;text text-anchor="middle" x="121.429" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;Sinatra API Server&lt;/text&gt;&lt;/g&gt;&amp;lt;!-- admin&amp;#45;&amp;gt;api --&amp;gt;&lt;g id="edge4" class="edge"&gt;&lt;title&gt;admin&amp;#45;&amp;gt;api&lt;/title&gt;&lt;path fill="none" stroke="black" d="M88.3056,-36.3034C93.4208,-44.4411 99.6247,-54.311 105.274,-63.2987"/&gt;&lt;polygon fill="black" stroke="black" points="102.393,-65.2919 110.678,-71.8957 108.319,-61.5667 102.393,-65.2919"/&gt;&lt;/g&gt;&amp;lt;!-- api&amp;#45;&amp;gt;app --&amp;gt;&lt;g id="edge3" class="edge"&gt;&lt;title&gt;api&amp;#45;&amp;gt;app&lt;/title&gt;&lt;path fill="none" stroke="black" d="M109.321,-108.433C102.869,-118.442 95.2835,-131.477 90.4292,-144 82.6849,-163.979 77.8136,-187.768 74.9446,-205.723"/&gt;&lt;polygon fill="black" stroke="black" points="71.4545,-205.398 73.4447,-215.804 78.3783,-206.428 71.4545,-205.398"/&gt;&lt;/g&gt;&amp;lt;!-- cmds --&amp;gt;&lt;g id="node4" class="node"&gt;&lt;title&gt;cmds&lt;/title&gt;&lt;polygon fill="none" stroke="black" points="247.254,-180 99.6049,-180 99.6049,-144 247.254,-144 247.254,-180"/&gt;&lt;text text-anchor="middle" x="173.429" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;Middleman Commands&lt;/text&gt;&lt;/g&gt;&amp;lt;!-- api&amp;#45;&amp;gt;cmds --&amp;gt;&lt;g id="edge2" class="edge"&gt;&lt;title&gt;api&amp;#45;&amp;gt;cmds&lt;/title&gt;&lt;path fill="none" stroke="black" d="M134.283,-108.303C140.454,-116.611 147.966,-126.723 154.753,-135.859"/&gt;&lt;polygon fill="black" stroke="black" points="151.95,-137.955 160.723,-143.896 157.569,-133.781 151.95,-137.955"/&gt;&lt;/g&gt;&amp;lt;!-- cmds&amp;#45;&amp;gt;app --&amp;gt;&lt;g id="edge1" class="edge"&gt;&lt;title&gt;cmds&amp;#45;&amp;gt;app&lt;/title&gt;&lt;path fill="none" stroke="black" d="M148.477,-180.124C135.388,-189.107 119.169,-200.237 104.993,-209.966"/&gt;&lt;polygon fill="black" stroke="black" points="102.742,-207.266 96.4771,-215.81 106.703,-213.038 102.742,-207.266"/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/p&gt;

&lt;p&gt;Let go through each of the components as if we were building them in our app directly.  The &lt;code&gt;gem&lt;/code&gt; does a lot of this for you, but it&amp;#39;s always nice to see how it works.&lt;/p&gt;

&lt;h2 id="static-middleman-site"&gt;Static Middleman Site&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re going to add our files in &lt;code&gt;source/admin&lt;/code&gt;, and &lt;code&gt;source/javascript/admin&lt;/code&gt; and &lt;code&gt;source/stylesheets/admin.scss&lt;/code&gt;.  All of these files will be rendered in development mode, so when the server is running locally and you load up &lt;a href="http://localhost:4567/admin"&gt;http://localhost:4567/admin&lt;/a&gt; we can use the middleman build process to load up our UI.  This, in turn, will use AJAX to pull in data from the running middleman instance.&lt;/p&gt;

&lt;p&gt;Inside of &lt;code&gt;config.rb&lt;/code&gt;, we tell middleman about our pages, and we tell the build process to ignore these files as part of the build process since we don&amp;#39;t want to release them into production:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;page &amp;quot;/admin/*html&amp;quot;, layout: &amp;quot;admin/layout&amp;quot;

# Build-specific configuration
configure :build do
  ignore &amp;#39;/admin/*&amp;#39;
  ignore &amp;#39;/stylesheets/admin/*&amp;#39;
  ignore &amp;#39;/javascripts/admin/*&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If they were not ignored, then you would be deploying a read-only version of the admin tools, since the production build would include the javascript application but not the API which is needed to make changes.&lt;/p&gt;

&lt;p&gt;This will allow us to create files like &lt;code&gt;/source/admin/drafts.json.erb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;% d = drafts.collect do |d|
    { path: d.path, title: d.title }
  end
%&amp;gt;&amp;lt;%= 
  {drafts: d }.to_json
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That we can load from our JS app like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;$.get( &amp;#39;/admin/drafts.json&amp;#39; ).then( function( data ) { console.log( data ) } );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that when we do &lt;code&gt;middleman build&lt;/code&gt; these files &lt;em&gt;will not&lt;/em&gt; be generated, since we&amp;#39;ve specified them as &lt;code&gt;ignore&lt;/code&gt;.  These files only are in the &lt;code&gt;:development&lt;/code&gt; environment.&lt;/p&gt;

&lt;h2 id="the-sinatra-app"&gt;The Sinatra App&lt;/h2&gt;

&lt;p&gt;That&amp;#39;s fine for static data, or data that can be exposed using normal middleman ways of doing things, but we&amp;#39;ll also want to be able to interact with the filesystem and run commands.  It&amp;#39;s also going to be useful to interact with the middleman &lt;em&gt;Sitemap&lt;/em&gt; as it understands it, so we can build a simple sinatra app that acts as a bridge.  The current version of the code I&amp;#39;m using for this blog can be found &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/blob/master/lib/middleman/blog/ui/api_server.rb"&gt;on github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First we need to &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;mount&lt;/code&gt; our app on &lt;code&gt;config.rb&lt;/code&gt;.  This is done like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;lib/apiserver.rb&amp;#39;

map &amp;quot;/api&amp;quot; do
  run ApiServer
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The commands we want to support are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get /api/post&lt;/code&gt; - load a specific post and metadata&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/post&lt;/code&gt; - save a post and update metadata&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/images&lt;/code&gt; - upload an image (for drag and drop) (not implemented)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/draft&lt;/code&gt; - create a new draft post&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/publish&lt;/code&gt; - change a draft into an article&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/update&lt;/code&gt; - run &lt;code&gt;git pull origin master 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/diff&lt;/code&gt; - run &lt;code&gt;git diff 2&amp;gt;$1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/status&lt;/code&gt; - run &lt;code&gt;git status 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/build&lt;/code&gt; - run &lt;code&gt;bundle exec middleman build 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post /api/deploy&lt;/code&gt; - run &lt;code&gt;bundle exec middleman deploy 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To reiterate right now the code is in more of a proof of concept, butso please feel free to make suggestions. Lets take a look at a few of these methods in &lt;code&gt;lib/api_server.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;sinatra/base&amp;#39;
require &amp;#39;sinatra/json&amp;#39;

class ApiServer &amp;lt; Sinatra::Base
  get &amp;#39;/&amp;#39; do
    &amp;quot;This is the api server&amp;quot;
  end

  get &amp;#39;/post&amp;#39; do
    app = load_app

    logger.info &amp;quot;Looking up #{params[:path]}&amp;quot;

    file = app.sitemap.find_resource_by_path params[:path] if params[:path]

    if !file
      status 404
      json error: &amp;quot;Unknown path #{params[:path]}&amp;quot;
    else
      raw = File.read file.source_file
      body = raw.gsub( /^---\n.*?---\n*/m, &amp;quot;&amp;quot; ) # Remove the preyaml

      json meta: file.data, content: body
    end
  end

  private
  def load_app
    opts = {}

    app = ::Middleman::Application.server.inst do
      set :environment, opts[:environment].to_sym if opts[:environment]

      logger
    end

    app
  end

  def logger
    ::Middleman::Logger.singleton( 1 )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="the-javascript-app"&gt;The Javascript App&lt;/h2&gt;

&lt;p&gt;I also wanted to see how to build this in &lt;a href="http://facebook.github.io/react/index.html"&gt;React&lt;/a&gt; and &lt;a href="https://github.com/reflux/refluxjs"&gt;Reflux&lt;/a&gt; to start exploring how we can start to add build-type rendering into the equation.  While this doesn&amp;#39;t do any server side rendering, its still good to explore how a React app actually works.&lt;/p&gt;

&lt;p&gt;The main html file simple calls &lt;code&gt;React.render( React.createElement(App, null), document.getElementById(&amp;#39;content&amp;#39;) );&lt;/code&gt; to setup the page.  The &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/blob/master/source/javascripts/admin/components/app.js.coffee"&gt;App&lt;/a&gt; component works off of the &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/blob/master/source/javascripts/admin/stores/article.coffee"&gt;pathStore&lt;/a&gt; component, which keeps track of what page the user is currently editing.  Lets take a quick look at how the &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/blob/master/source/javascripts/admin/components/dashboard_draft_list.js.coffee"&gt;DashboardDraftList&lt;/a&gt; component works:&lt;/p&gt;

&lt;pre&gt;&lt;code class="coffeescript"&gt;@DashboardDraftList = React.createClass
  mixins: [Reflux.connect(draftStore)],

  getInitialState: -&amp;gt;
    drafts: []

  componentDidMount: -&amp;gt; updateDraftList()

  render: -&amp;gt;
    drafts = @state.drafts.map (item) -&amp;gt;
      &amp;lt;li key={item.path}&amp;gt;&amp;lt;a onClick={viewPath.bind(this, item.path)}&amp;gt;{item.title}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;

    &amp;lt;div className=&amp;quot;maincontent&amp;quot;&amp;gt;
      &amp;lt;h1&amp;gt;Drafts&amp;lt;/h1&amp;gt;

      &amp;lt;ul className=&amp;quot;nav nav-pills nav-stacked&amp;quot;&amp;gt;
        {drafts}
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing that this does is wire itself up to the &lt;code&gt;draftStore&lt;/code&gt; store which manages the communication to the server and the state received from the server.  When this changes, &lt;code&gt;draftStore&lt;/code&gt; will trigger a state change and all components that have been connected will receive a &lt;code&gt;setState&lt;/code&gt; message, which will then call the &lt;code&gt;render&lt;/code&gt; method of the component keeping the UI up to date.   As part of the React component life cycle &lt;code&gt;componentDidMount&lt;/code&gt;, we call the &lt;code&gt;updateDraftList()&lt;/code&gt; action when the component is first loaded on the page.  This is defined in &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/blob/master/source/javascripts/admin/stores/drafts.coffee"&gt;drafts store&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="coffeescript"&gt;@updateDraftList = Reflux.createAction
  asyncResult: true

@draftStore = Reflux.createStore
  init: -&amp;gt;
    @drafts = []
    @listenTo( updateDraftList, @onUpdateDrafts )

  onUpdateDrafts: -&amp;gt;
    request.get &amp;quot;/admin/drafts.json&amp;quot;, (err, response) =&amp;gt;
      if response.ok
        updateDraftList.completed( response.body )
        @drafts = response.body
        @trigger @drafts
      else
        updateDraftList.failed(response.error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we do is to define and export a &lt;code&gt;Reflux&lt;/code&gt; action called &lt;code&gt;updateDraftList&lt;/code&gt;.  This action is what the &lt;code&gt;componentDidMount&lt;/code&gt; function triggeres.  Inside of the &lt;code&gt;draftStore&lt;/code&gt; we listen for that action, and when it get it, call &lt;code&gt;onUpdateDrafts&lt;/code&gt;.  This uses request.get to load up the json from &lt;code&gt;/admin/drafts.json&lt;/code&gt; and then pushes it out to all of the components that have subscribed to it.&lt;/p&gt;

&lt;p&gt;The other components are &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/tree/master/source/javascripts/admin/components"&gt;defined here&lt;/a&gt; and the different stores can be &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/tree/master/source/javascripts/admin/stores"&gt;found here&lt;/a&gt;.  This is my first real React app so I&amp;#39;m sure there&amp;#39;s cleaner/better ways of doing things...&lt;/p&gt;

&lt;h2 id="putting-it-all-together"&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;When I was working on this I did it out of the source directory of this blog, but I wanted to package it up into a gem so that other folks could use it.  I pulled the relavent code out from &lt;code&gt;willschenk.com/source&lt;/code&gt; into &lt;code&gt;middleman-blog-ui/source&lt;/code&gt; and then created a middleman extension to put the various templates in the sitemap, tell sprockets where to find the javascript files, and setup coffee script.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/HappyFunCorp/middleman-blog-ui/blob/master/lib/middleman/blog/ui/extension.rb"&gt;full code&lt;/a&gt; is found on github, but to explain how it works:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Define &lt;code&gt;SOURCE_DIR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Map the sinatra app &lt;code&gt;ApiServer&lt;/code&gt; in the extentions &lt;code&gt;initialize&lt;/code&gt; method, using &lt;code&gt;app.map&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Register the CoffeeScript processing using &lt;code&gt;::Sprockets.register_preprocessor &amp;#39;application/javascript&amp;#39;, ::Sprockets::CoffeeReact&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;after_configuration&lt;/code&gt; to register the application templates, by creating &lt;code&gt;Middleman::Sitemap::Resource&lt;/code&gt; objects mapping the sitemap urls with the filesytem paths.&lt;/li&gt;
&lt;li&gt;Adding each of the javascript and stylesheet files to &lt;code&gt;app.sprockets&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="next-steps"&gt;Next steps&lt;/h2&gt;

&lt;p&gt;This is mainly a proof of concept, but I&amp;#39;m using it right now to write this post.  The app itself needs&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A decent UI&lt;/li&gt;
&lt;li&gt;Support for other static generators other than middleman&lt;/li&gt;
&lt;li&gt;A concept of users&lt;/li&gt;
&lt;li&gt;Shared drafts&lt;/li&gt;
&lt;li&gt;Better error handling&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you are at all interested in this, please let me know!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Receiving posted JSON with Sinatra</title>
    <link rel="alternate" href="http://willschenk.com/receiving-posted-json-with-sinatra/"/>
    <id>http://willschenk.com/receiving-posted-json-with-sinatra/</id>
    <published>2015-07-26T20:00:00-04:00</published>
    <updated>2015-07-26T20:00:00-04:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Here&amp;#39;s some simple code to accept a JSON string posted to a &lt;a href="http://www.sinatrarb.com"&gt;Sinatra&lt;/a&gt; end point rather than a form. I switched from using &lt;a href="http://jquery.com"&gt;jQueries&lt;/a&gt; &lt;code&gt;$.ajax&lt;/code&gt; method to &lt;a href="https://github.com/visionmedia/superagent"&gt;superagent&lt;/a&gt; as part of my exploration of the node javascript package universe, and it has a different way of serializing nest objects when posting as a form.  Specifically, it doesn&amp;#39;t.&lt;/p&gt;

&lt;p&gt;I needed something that could do both.&lt;/p&gt;

&lt;h2 id="code-to-use-form-encoding-or-json-blob"&gt;Code to use form encoding or JSON blob&lt;/h2&gt;

&lt;p&gt;This first tries and loads the parameters using the normal form encoding methods.  If it doesn&amp;#39;t find the &lt;code&gt;path&lt;/code&gt; parameter, it attempts to parse the body&amp;#39;s payload, found in &lt;code&gt;request.body.read&lt;/code&gt;, using &lt;code&gt;JSON.parse&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  post &amp;#39;/post&amp;#39; do
    payload = params 
    payload = JSON.parse(request.body.read).symbolize_keys unless params[:path]

    logger.info &amp;quot;Saving #{payload[:path]} with #{payload[:meta]}&amp;quot;

    file = load_app.sitemap.find_resource_by_path payload[:path]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="javascript"&gt;Javascript&lt;/h2&gt;

&lt;p&gt;The coffeescript that calls this is:&lt;/p&gt;

&lt;pre&gt;&lt;code class="coffeescript"&gt;request.post &amp;quot;/api/post&amp;quot;
  .set(&amp;#39;Content-Type&amp;#39;, &amp;#39;application/json&amp;#39;)
  .send path: @state.path, meta: @state.metadata, body: @state.markdown
  .end (err, response) =&amp;gt;
    if response.ok
      @state.saving = false
      @state.dirty = false
      @trigger @state
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, &lt;code&gt;@state.metadata&lt;/code&gt; is also a complex object, and posting it as JSON ensures that it&amp;#39;s marshalled correctly.&lt;/p&gt;

&lt;p&gt;Not too complicated.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Bower with Rails</title>
    <link rel="alternate" href="http://willschenk.com/bower-with-rails/"/>
    <id>http://willschenk.com/bower-with-rails/</id>
    <published>2015-07-24T22:01:00-04:00</published>
    <updated>2015-07-24T22:01:00-04:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Let&amp;#39;s look at how we can integrate bower with rails and Sprockets. &lt;a href="http://bower.io"&gt;Bower&lt;/a&gt; is one of the two major javascript package managers, the other being the Node Package Manager, or &lt;a href="https://www.npmjs.com"&gt;npm&lt;/a&gt;.  The biggest difference between the two is how the javascript is packaged up.  Bower is the more straightforward of the two, and it mainly a way to distribute javascript and keep things up to date.&lt;/p&gt;

&lt;h2 id="install-bower"&gt;Install Bower&lt;/h2&gt;

&lt;p&gt;The first step is to install bower.  Ironically, we need to use npm to do that!  On OSX, the easiest way is to use the &lt;a href="http://brew.sh"&gt;Homebrew&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ brew install node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;#39;s install bower in your local command path so you can run it.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ npm install -g bower
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="setup-bower"&gt;Setup Bower&lt;/h2&gt;

&lt;p&gt;Now let&amp;#39;s setup rails to work with bower.  This section assumes that you already have a rails application.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;cd rails_application
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a &lt;code&gt;.bowerrc&lt;/code&gt; file. This is going to tell bower where to install the packages it needs, and we&amp;#39;re going to say put it in &lt;code&gt;vendor/assets/bower_components&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
  &amp;quot;directory&amp;quot;: &amp;quot;vendor/assets/bower_components&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run &lt;code&gt;bower init&lt;/code&gt; to create a &lt;code&gt;bower.json&lt;/code&gt; file.  This file is similar to a &lt;code&gt;Gemfile&lt;/code&gt;, in that it lists out the dependancies, and when you run bower again, it will download the specific versions from the intertubes.&lt;/p&gt;

&lt;h2 id="tell-rails-where-to-look"&gt;Tell rails where to look&lt;/h2&gt;

&lt;p&gt;Inside of &lt;code&gt;config/application.rb&lt;/code&gt; we&amp;#39;re going to tell spockets and additional directory to look for javascript components.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;config.assets.paths &amp;lt;&amp;lt; Rails.root.join(&amp;#39;vendor&amp;#39;, &amp;#39;assets&amp;#39;, &amp;#39;bower_components&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="small-walk-through"&gt;Small walk through&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s say you want to use Google Maps with Angular.  &lt;a href="http://angular-ui.github.io/angular-google-maps/#!/"&gt;angular-google-maps&lt;/a&gt; is a package that does a lot of the heavy lifting for you, so lets install that.  We&amp;#39;re going to tell bower to keep track of the packages we want inside of our &lt;code&gt;bower.json&lt;/code&gt; file by passing in the &lt;code&gt;--save&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bower install --save angular-google-maps
[...]
angular-google-maps#2.1.5 vendor/assets/bower_components/angular-google-maps
 angular#1.4.3
 lodash#3.10.0

lodash#3.10.0 vendor/assets/bower_components/lodash

angular#1.4.3 vendor/assets/bower_components/angular
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;ve cleaned up some of the output, but you can see that bower installed angular-google-maps and it&amp;#39;s dependancies, angular itself and lodash.  Lets go to our &lt;code&gt;application.js&lt;/code&gt; file now to tell Sprockets that we want to use this awesome stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;//= require lodash
//= require angular
//= require angular-google-maps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we&amp;#39;ve added &lt;code&gt;vendor/assets/bower_components&lt;/code&gt; in Sprockets load path, it should be able to find all of these files.  Notice that you don&amp;#39;t need to know where to get all of the dependancies from, but you do need to make sure that you specify them in your &lt;code&gt;application.js&lt;/code&gt; in the right order.  We&amp;#39;ll be talking about &lt;code&gt;browersify&lt;/code&gt; in future posts that assuages this issue.&lt;/p&gt;

&lt;h2 id="to-check-in-or-not-to-check-in"&gt;To check in or not to check in&lt;/h2&gt;

&lt;p&gt;I prefer to check in the dependancies inside of my source control.  This isn&amp;#39;t necessary and in some ways is a waste of disk space, but I think it&amp;#39;s easier to figure out what&amp;#39;s going on if there&amp;#39;s less magic.  This can be confusion if you start to make local tweaks of the javascript, which you should never do.&lt;/p&gt;

&lt;p&gt;However, it&amp;#39;s not necessary to check things in if you expand your build process a bit.  If you look inside of your &lt;code&gt;bower.json&lt;/code&gt; file, you&amp;#39;ll see that it specifies the specific version of the bower package that you installed.&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;rails_app&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.0&amp;quot;,
  &amp;quot;authors&amp;quot;: [
    &amp;quot;Will Schenk &amp;lt;wschenk@gmail.com&amp;gt;&amp;quot;
  ],
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;ignore&amp;quot;: [
    &amp;quot;**/.*&amp;quot;,
    &amp;quot;node_modules&amp;quot;,
    &amp;quot;bower_components&amp;quot;,
    &amp;quot;test&amp;quot;,
    &amp;quot;tests&amp;quot;
  ],
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;angular-google-maps&amp;quot;: &amp;quot;~2.1.5&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should contain all the information needed so that when you run &lt;code&gt;bower install&lt;/code&gt; again, all of the correct versions of the files will be downloaded.  You could make it part of your build process, much like how running &lt;code&gt;bundle install&lt;/code&gt; is part of the standard rails build pack.  Bundler looks through &lt;code&gt;Gemfile.lock&lt;/code&gt; and installs those specific packages.  The version is always specified inside of &lt;code&gt;bower.json&lt;/code&gt; so there doesn&amp;#39;t need to be two files.&lt;/p&gt;
</content>
  </entry>
</feed>
