<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blank Page Tech</title>
  <subtitle>Lets build things</subtitle>
  <id>http://willschenk.com/</id>
  <link href="http://willschenk.com/"/>
  <link href="http://willschenk.com/feed.xml" rel="self"/>
  <updated>2015-01-16T14:37:55-05:00</updated>
  <author>
    <name>Will Schenk</name>
  </author>
  <entry>
    <title>Setting up Devise with Twitter and Facebook and other Omniauth schemes without email addresses</title>
    <link rel="alternate" href="http://willschenk.com/setting-up-devise-with-twitter-and-facebook-and-other-omniauth-schemes-without-email-addresses/"/>
    <id>http://willschenk.com/setting-up-devise-with-twitter-and-facebook-and-other-omniauth-schemes-without-email-addresses/</id>
    <published>2015-01-15T19:00:00-05:00</published>
    <updated>2015-01-15T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Adding social login to your sites really makes it easier to get users onboard.  Devise is great to help get an authentication system up and running, but there are a few tricky things to get right.  The first challenge is that you don&amp;#39;t always get the user&amp;#39;s email address when the first connect.  The second challenge is that we want to request the minimum permissions first so that the user is more likely to sign up, and gradually ask more as the time arrises.&lt;/p&gt;

&lt;p&gt;This post is going to go through the strategy that &lt;a href="http://seed.happyfuncorp.com"&gt;happy_seed&lt;/a&gt; uses to support these use cases.  The easiest way to get started is to use seed to get things up and running, but we&amp;#39;ll walk through how to do it all in detail below.&lt;/p&gt;

&lt;h2 id="install-devise-and-omniauth"&gt;Install devise and omniauth&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s install a few gems.  We&amp;#39;ll go through how to install twitter, facebook, and google.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;#39;devise&amp;#39;, &amp;#39;~&amp;gt; 3.4&amp;#39;
gem &amp;#39;omniauth&amp;#39;
gem &amp;#39;omniauth-twitter&amp;#39;
gem &amp;#39;omniauth-facebook&amp;#39;
gem &amp;#39;omniauth-instagram&amp;#39;
gem &amp;#39;twitter&amp;#39;
gem &amp;#39;instagram&amp;#39;
gem &amp;#39;omniauth-google-oauth2&amp;#39;
gem &amp;#39;google-api-client&amp;#39;, require: &amp;#39;google/api_client&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to run the &lt;code&gt;devise&lt;/code&gt; generators.  I like to copy over the views so that I can fix them up to look like the rest of my app.  If you are using seed, these views will be generated with &lt;code&gt;HAML&lt;/code&gt; and the &lt;code&gt;bootstrap helpers&lt;/code&gt; gem.&lt;/p&gt;

&lt;p&gt;First install devise:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails generate devise:install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;devise:install&lt;/code&gt; copies over &lt;code&gt;config/initializers/devise.rb&lt;/code&gt; and a localized message file.  We will configure devise here.  &lt;em&gt;Follow the outputed instuctions to setup flashes and mailer configs.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now create a model, call it user:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails generate devise User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a &lt;code&gt;User&lt;/code&gt; model and configures devise routes to use it.  We will edit both of these.&lt;/p&gt;

&lt;p&gt;Finally, copy over the views so you can style them as you need:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails generate devise:views
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="make-sure-regular-login-in-works"&gt;Make sure regular login in works&lt;/h2&gt;

&lt;p&gt;Lets create a basic controller to see if our login works:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails g controller welcome index
$ rake db:migrate
$ rails s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit &lt;code&gt;routes.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  get &amp;#39;welcome/index&amp;#39;
  root &amp;#39;welcome#index&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And change your &lt;code&gt;WeclomeController&lt;/code&gt; to require user authentication:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class WelcomeController
  before_action :authenticate_user!

  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you go to &lt;a href="http://localhost:3000/"&gt;http://localhost:3000/&lt;/a&gt; you should get redirected to a login page.  If you create a user you should be able to then see the protected page.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s add a logout button to the index page for testing: &lt;code&gt;app/views/welcome/index.html.erb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%= link_to &amp;quot;Signout&amp;quot;, destroy_user_session_path, method: :delete %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can go back and forth.  The &lt;code&gt;method: :delete&lt;/code&gt; part is something that I often forget about.&lt;/p&gt;

&lt;h2 id="configure-omniauth"&gt;Configure Omniauth&lt;/h2&gt;

&lt;p&gt;We need to tell devise and omniauth how to talk to the various outside services.  The first thing you&amp;#39;ll need to do is configure those services and collect their app ids and app secrets.  Then you put that information inside of &lt;code&gt;config/initializers/devise.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;    config.omniauth :google_oauth2, ENV[&amp;#39;GOOGLE_OAUTH2_APP_ID&amp;#39;], ENV[&amp;#39;GOOGLE_OAUTH2_APP_SECRET&amp;#39;], scope: &amp;quot;email,profile,offline&amp;quot;, prompt: &amp;quot;consent&amp;quot;
    config.omniauth :instagram, ENV[&amp;#39;INSTAGRAM_APP_ID&amp;#39;], ENV[&amp;#39;INSTAGRAM_APP_SECRET&amp;#39;]
    config.omniauth :facebook, ENV[&amp;#39;FACEBOOK_APP_ID&amp;#39;], ENV[&amp;#39;FACEBOOK_APP_SECRET&amp;#39;], scope: &amp;quot;email&amp;quot;
    config.omniauth :twitter, ENV[&amp;#39;TWITTER_APP_ID&amp;#39;], ENV[&amp;#39;TWITTER_APP_SECRET&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we are building nice &lt;a href="http://12factor.net"&gt;12 Factor Apps&lt;/a&gt; we pull the config from the environment.  seed uses the &lt;a href="https://github.com/bkeepers/dotenv"&gt;dotenv gem&lt;/a&gt; to keep track of these things in a &lt;code&gt;.env&lt;/code&gt; file, and when you deploy to heroku you will use heroku config variables.&lt;/p&gt;

&lt;p&gt;We also pass in &lt;code&gt;scope&lt;/code&gt;s to a few strategies, which is where we can configure omniauth to request specific permissions.  Sometimes you need to enable them on the remote side before you can request things (&lt;em&gt;e.g.&lt;/em&gt; google, twitter) so make sure that things are setup there.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll go into how to dynamically set that scope later on.&lt;/p&gt;

&lt;h2 id="tell-devise-about-omniauthable"&gt;Tell Devise about omniauthable&lt;/h2&gt;

&lt;p&gt;Open up &lt;code&gt;app/models/user.rb&lt;/code&gt; and add &lt;code&gt;:omniauthable&lt;/code&gt; to your &lt;code&gt;devise&lt;/code&gt; line and remove &lt;code&gt;:validatable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  devise :omniauthable, :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should see that there are a list of connect with our services when you go to your sign in or login pages.&lt;/p&gt;

&lt;h2 id="create-a-formuser-to-handle-validations"&gt;Create a FormUser to handle validations&lt;/h2&gt;

&lt;p&gt;Not all services return email addresses, and by default the devise validations expect them.  Let&amp;#39;s move those validations out of the base &lt;code&gt;User&lt;/code&gt; class into a &lt;code&gt;FormUser&lt;/code&gt; class.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remove &lt;code&gt;:validatable&lt;/code&gt; from &lt;code&gt;app/models/user.rb&lt;/code&gt; (which you&amp;#39;ve done above)&lt;/li&gt;
&lt;li&gt;Tell devise to use our new model.&lt;/li&gt;
&lt;li&gt;Create the forms_user.rb class.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Inside of &lt;code&gt;config/routes.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;devise_for :users, class_name: &amp;#39;FormUser&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;code&gt;app/models/form_user.rb&lt;/code&gt; should look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class FormUser &amp;lt; User
  attr_accessor :current_password

  validates_presence_of   :email, if: :email_required?
  validates_uniqueness_of :email, allow_blank: true, if: :email_changed?
  validates_format_of     :email, with: Devise.email_regexp, allow_blank: true, if: :email_changed?

  validates_presence_of     :password, if: :password_required?
  validates_confirmation_of :password, if: :password_required?
  validates_length_of       :password, within: Devise.password_length, allow_blank: true

  def password_required?
    return false if email.blank?
    !persisted? || !password.nil? || !password_confirmation.nil?
  end

  def email_required?
    true
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;class_name&lt;/code&gt; inside of the devise config will tell it to use this class for building forms, and we have the validations on this class so our error messages will work on the site, but we&amp;#39;ll be able to save objects without it.&lt;/p&gt;

&lt;h2 id="create-identity-model-to-store-access_keys-and-metadata"&gt;Create Identity model to store access_keys and metadata&lt;/h2&gt;

&lt;p&gt;Now we are ready to plug in oauth authentications.  The flow is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;User requests &lt;code&gt;/users/auth/:provider&lt;/code&gt;, where provider one of the strategies that you defined above.&lt;/li&gt;
&lt;li&gt;Omniauth does magic and directs the user to the remote service.&lt;/li&gt;
&lt;li&gt;The user grants us access and is redirected to the callback path.&lt;/li&gt;
&lt;li&gt;The OmniauthCallbacks controller is called on our application with the relavent info.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will use this info to create the user.  We are also going to store it to be able to access the service on behalf of the user, and we&amp;#39;ll need to store the &lt;code&gt;access_token&lt;/code&gt; in order to do so.&lt;/p&gt;

&lt;p&gt;Google is slightly more complicated and we&amp;#39;ll need to store a &lt;code&gt;refresh_token&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Lets create that model now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails model identity user:references provider:string accesstoken:string refreshtoken:string uid:string name:string email:string nickname:string image:string phone:string urls:string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And flesh out &lt;code&gt;app/models/identity.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class Identity &amp;lt; ActiveRecord::Base
  belongs_to :user
  validates_presence_of :uid, :provider
  validates_uniqueness_of :uid, :scope =&amp;gt; :provider

  def self.find_for_oauth(auth)
    identity = find_by(provider: auth.provider, uid: auth.uid)
    identity = create(uid: auth.uid, provider: auth.provider) if identity.nil?
    identity.accesstoken = auth.credentials.token
    identity.refreshtoken = auth.credentials.refresh_token
    identity.name = auth.info.name
    identity.email = auth.info.email
    identity.nickname = auth.info.nickname
    identity.image = auth.info.image
    identity.phone = auth.info.phone
    identity.urls = (auth.info.urls || &amp;quot;&amp;quot;).to_json
    identity.save
    identity
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to tell devise to use this model.&lt;/p&gt;

&lt;h2 id="create-omniauthcallbackscontroller-to-pull-in-data"&gt;Create OmniauthCallbacksController to pull in data&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re going to build one method to handle the different authentication callbacks, called &lt;code&gt;generic_callback&lt;/code&gt;.  The logic of this controller is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find or create an &lt;code&gt;Identity&lt;/code&gt; object for the incoming oauth data.  Update it with the latest info.&lt;/li&gt;
&lt;li&gt;If there is no user associated with the Identity, associate it with the current_user.&lt;/li&gt;
&lt;li&gt;If there is no current_user, create a new User object.&lt;/li&gt;
&lt;li&gt;If the User object doesn&amp;#39;t have an email address set yet, but we do have one from the remote service, set the email address to that.&lt;/li&gt;
&lt;li&gt;Log the user in and let the continue on their way.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;First we need to tell devise about our controller in &lt;code&gt;routes.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;devise_for :users, class_name: &amp;#39;FormUser&amp;#39;, :controllers =&amp;gt; { omniauth_callbacks: &amp;#39;omniauth_callbacks&amp;#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create &lt;code&gt;app/controllers/omniauth_callback_controller.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class OmniauthCallbacksController &amp;lt; Devise::OmniauthCallbacksController
  def instagram
    generic_callback( &amp;#39;instagram&amp;#39; )
  end

  def facebook
    generic_callback( &amp;#39;facebook&amp;#39; )
  end

  def twitter
    generic_callback( &amp;#39;twitter&amp;#39; )
  end

  def google_oauth2
    generic_callback( &amp;#39;google_oauth2&amp;#39; )
  end

  def generic_callback( provider )
    @identity = Identity.find_for_oauth env[&amp;quot;omniauth.auth&amp;quot;]

    @user = @identity.user || current_user
    if @user.nil?
      @user = User.create( email: @identity.email || &amp;quot;&amp;quot; )
      @identity.update_attribute( :user_id, @user.id )
    end

    if @user.email.blank? &amp;amp;&amp;amp; @identity.email
      @user.update_attribute( :email, @identity.email)
    end

    if @user.persisted?
      @identity.update_attribute( :user_id, @user.id )
      # This is because we&amp;#39;ve created the user manually, and Device expects a
      # FormUser class (with the validations)
      @user = FormUser.find @user.id
      sign_in_and_redirect @user, event: :authentication
      set_flash_message(:notice, :success, kind: provider.capitalize) if is_navigational_format?
    else
      session[&amp;quot;devise.#{provider}_data&amp;quot;] = env[&amp;quot;omniauth.auth&amp;quot;]
      redirect_to new_user_registration_url
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="override-registrationscontroller-to-handle-adding-email-address-and-password"&gt;Override RegistrationsController to handle adding email address and password&lt;/h2&gt;

&lt;p&gt;We want to let the user add an email address if they haven&amp;#39;t already, and also let them set a password if they haven&amp;#39;t already set one.  (Otherwise it requires the user to enter in &lt;code&gt;current_password&lt;/code&gt;.)  Lets first tell devise about our new controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;devise_for :users, class_name: &amp;#39;FormUser&amp;#39;, :controllers =&amp;gt; { omniauth_callbacks: &amp;#39;omniauth_callbacks&amp;#39;, registrations: &amp;#39;registrations&amp;#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then create that controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class RegistrationsController &amp;lt; Devise::RegistrationsController
  def update_resource(resource, params)
    if resource.encrypted_password.blank? # || params[:password].blank?
      resource.email = params[:email] if params[:email]
      if !params[:password].blank? &amp;amp;&amp;amp; params[:password] == params[:password_confirmation]
        logger.info &amp;quot;Updating password&amp;quot;
        resource.password = params[:password]
        resource.save
      end
      if resource.valid?
        resource.update_without_password(params)
      end
    else
      resource.update_with_password(params)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we should be good!  Give it a go and see how it looks!&lt;/p&gt;

&lt;h2 id="adding-methods-to-user-to-get-to-the-clients"&gt;Adding methods to User to get to the clients&lt;/h2&gt;

&lt;p&gt;This goes into &lt;code&gt;app/models/users.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  has_many :identities

  def twitter
    identities.where( :provider =&amp;gt; &amp;quot;twitter&amp;quot; ).first
  end

  def twitter_client
    @twitter_client ||= Twitter.client( access_token: twitter.accesstoken )
  end

  def facebook
    identities.where( :provider =&amp;gt; &amp;quot;facebook&amp;quot; ).first
  end

  def facebook_client
    @facebook_client ||= Facebook.client( access_token: facebook.accesstoken )
  end

  def instagram
    identities.where( :provider =&amp;gt; &amp;quot;instagram&amp;quot; ).first
  end

  def instagram_client
    @instagram_client ||= Instagram.client( access_token: instagram.accesstoken )
  end

  def google_oauth2
    identities.where( :provider =&amp;gt; &amp;quot;google_oauth2&amp;quot; ).first
  end

  def google_oauth2_client
    if !@google_oauth2_client
      @google_oauth2_client = Google::APIClient.new(:application_name =&amp;gt; &amp;#39;HappySeed App&amp;#39;, :application_version =&amp;gt; &amp;quot;1.0.0&amp;quot; )
      @google_oauth2_client.authorization.update_token!({:access_token =&amp;gt; google_oauth2.accesstoken, :refresh_token =&amp;gt; google_oauth2.refreshtoken})
    end
    @google_oauth2_client
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can access a configured API client using things like &lt;code&gt;current_user.twitter&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="passing-dynamic-scopes-to-omniauth"&gt;Passing dynamic scopes to omniauth&lt;/h2&gt;

&lt;p&gt;In the current scheme above, you have to hard code the scopes that you want to request for the user which doesn&amp;#39;t always work.  It would be better to only request write access if the user really needs to have it, and by default only get read-only access.  In order to do this we can leverage the &lt;code&gt;Omniauth&lt;/code&gt; setup property.  Inside of &lt;code&gt;devise.rb&lt;/code&gt; add &lt;code&gt;setup: true&lt;/code&gt; to each of the services you want to be able to upgrade.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;    config.omniauth :google_oauth2, ENV[&amp;#39;GOOGLE_OAUTH2_APP_ID&amp;#39;], ENV[&amp;#39;GOOGLE_OAUTH2_APP_SECRET&amp;#39;], scope: &amp;quot;email,profile,offline&amp;quot;, prompt: &amp;quot;consent&amp;quot;, setup: true
    config.omniauth :instagram, ENV[&amp;#39;INSTAGRAM_APP_ID&amp;#39;], ENV[&amp;#39;INSTAGRAM_APP_SECRET&amp;#39;], setup: true
    config.omniauth :facebook, ENV[&amp;#39;FACEBOOK_APP_ID&amp;#39;], ENV[&amp;#39;FACEBOOK_APP_SECRET&amp;#39;], scope: &amp;quot;email&amp;quot;, setup: true
    config.omniauth :twitter, ENV[&amp;#39;TWITTER_APP_ID&amp;#39;], ENV[&amp;#39;TWITTER_APP_SECRET&amp;#39;], setup: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s add a few routes in &lt;code&gt;routes.rb&lt;/code&gt; that we can have the user link to:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  devise_scope :user do
    get &amp;#39;/users/auth/:provider/upgrade&amp;#39; =&amp;gt; &amp;#39;omniauth_callbacks#upgrade&amp;#39;, as: :user_omniauth_upgrade
    get &amp;#39;/users/auth/:provider/setup&amp;#39;, :to =&amp;gt; &amp;#39;omniauth_callbacks#setup&amp;#39;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first route is something that we&amp;#39;ll have the user link to, using &lt;code&gt;user_omniauth_upgrade_path( :google_oauth2 )&lt;/code&gt; for example.  The second &lt;code&gt;setup&lt;/code&gt; route is what omniauth will call internally that we can use to change the &lt;code&gt;scope&lt;/code&gt; parameter.  These go into &lt;code&gt;omniauth_callbacks_controller.rb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first &lt;code&gt;upgrade&lt;/code&gt; method looks at the provider and sets a &lt;code&gt;flash&lt;/code&gt; variable for the additional access.  In this case, we are asking for the &lt;code&gt;https://www.googleapis.com/auth/admin.directory.user&lt;/code&gt; also.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def upgrade
    scope = nil
    if params[:provider] == &amp;quot;google_oauth2&amp;quot;
      scope = &amp;quot;email,profile,offline,https://www.googleapis.com/auth/admin.directory.user&amp;quot;
    end

    redirect_to user_omniauth_authorize_path( params[:provider] ), flash: { scope: scope }
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it directs the user back to the normal flow.&lt;/p&gt;

&lt;p&gt;When you specify &lt;code&gt;setup: true&lt;/code&gt; inside of the omniauth configuration, there is magic that calls the &lt;code&gt;setup_path&lt;/code&gt; by default, and this is the method where we change the scope from the default in the strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def setup
    request.env[&amp;#39;omniauth.strategy&amp;#39;].options[&amp;#39;scope&amp;#39;] = flash[:scope] || request.env[&amp;#39;omniauth.strategy&amp;#39;].options[&amp;#39;scope&amp;#39;]
    render :text =&amp;gt; &amp;quot;Setup complete.&amp;quot;, :status =&amp;gt; 404
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now in your views, you can do&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%= link_to &amp;quot;Upgrade Access&amp;quot;, user_omniauth_upgrade_path( :google_oauth2 ) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the user will go through the oauth flow again requesting the additional access.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Making all of this work is possible, but there are a lot of fiddly little bits to make it work.  Both devise and all of the many omniauth strategies out there make it easy to add this functionality to your application.&lt;/p&gt;

&lt;p&gt;Check out &lt;a href="http://seed.happyfuncorp.com"&gt;seed&lt;/a&gt; to quickly create an application will all of this stuff done for you!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using rake for dataflow programming and data science</title>
    <link rel="alternate" href="http://willschenk.com/using-rake-for-dataflow-programming-and-data-science/"/>
    <id>http://willschenk.com/using-rake-for-dataflow-programming-and-data-science/</id>
    <published>2014-12-18T19:00:00-05:00</published>
    <updated>2014-12-18T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;#39;ve been using Rake more and more for data collection and processing tasks.  Rake is pretty pretty powerful.  Most people know it as way to add external tasks to a Rails app, but it&amp;#39;s actually very powerful build system.  We&amp;#39;re going to take advantage of that to build out a &lt;a href="https://github.com/HappyFunCorp/rake-data"&gt;framework&lt;/a&gt; that will make it easy to collect, process, and interpret data while keeping it all in sync.&lt;/p&gt;

&lt;p&gt;In fact, if you just want to start playing with stuff now, head over to the &lt;a href="https://github.com/HappyFunCorp/rake-data"&gt;rake-data&lt;/a&gt; site to go through some walk throughs.  Read on to setup a fun world of your own!&lt;/p&gt;

&lt;h2 id="rejected-titles-of-this-post"&gt;Rejected titles of this post&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;rake and bake&lt;/li&gt;
&lt;li&gt;rake me up before you go-go&lt;/li&gt;
&lt;li&gt;let them eat rake&lt;/li&gt;
&lt;li&gt;rake it until you make it&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="tasks-and-dependancies"&gt;Tasks and Dependancies&lt;/h2&gt;

&lt;p&gt;Rake is a a Make-like Ruby program that people know mostly in terms of rails apps.  We can define a few tasks and define their interdependancies:&lt;/p&gt;

&lt;div class="diagram_right"&gt;
&lt;svg width="291pt" height="188pt" viewBox="0.00 0.00 291.36 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"&gt;&lt;title&gt;G&lt;/title&gt;&lt;polygon fill="white" stroke="none" points="-4,4 -4,-184 287.355,-184 287.355,4 -4,4"/&gt;&lt;!-- a --&gt;&lt;g id="node1" class="node"&gt;&lt;title&gt;a&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="93.105" cy="-162" rx="93.2101" ry="18"/&gt;&lt;text text-anchor="middle" x="93.105" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;mail daily leaderboards&lt;/text&gt;&lt;/g&gt;&lt;!-- b --&gt;&lt;g id="node2" class="node"&gt;&lt;title&gt;b&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="93.105" cy="-90" rx="83.0546" ry="18"/&gt;&lt;text text-anchor="middle" x="93.105" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;update leader boards&lt;/text&gt;&lt;/g&gt;&lt;!-- a&amp;#45;&amp;gt;b --&gt;&lt;g id="edge1" class="edge"&gt;&lt;title&gt;a&amp;#45;&amp;gt;b&lt;/title&gt;&lt;path fill="none" stroke="black" d="M93.105,-143.697C93.105,-135.983 93.105,-126.712 93.105,-118.112"/&gt;&lt;polygon fill="black" stroke="black" points="96.6051,-118.104 93.105,-108.104 89.6051,-118.104 96.6051,-118.104"/&gt;&lt;/g&gt;&lt;!-- c --&gt;&lt;g id="node3" class="node"&gt;&lt;title&gt;c&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="166.105" cy="-18" rx="54.6076" ry="18"/&gt;&lt;text text-anchor="middle" x="166.105" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;environment&lt;/text&gt;&lt;/g&gt;&lt;!-- b&amp;#45;&amp;gt;c --&gt;&lt;g id="edge2" class="edge"&gt;&lt;title&gt;b&amp;#45;&amp;gt;c&lt;/title&gt;&lt;path fill="none" stroke="black" d="M110.776,-72.055C120.057,-63.1558 131.574,-52.1121 141.693,-42.4085"/&gt;&lt;polygon fill="black" stroke="black" points="144.304,-44.7545 149.099,-35.307 139.459,-39.702 144.304,-44.7545"/&gt;&lt;/g&gt;&lt;!-- d --&gt;&lt;g id="node4" class="node"&gt;&lt;title&gt;d&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="239.105" cy="-90" rx="44.0015" ry="18"/&gt;&lt;text text-anchor="middle" x="239.105" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;flush data&lt;/text&gt;&lt;/g&gt;&lt;!-- d&amp;#45;&amp;gt;c --&gt;&lt;g id="edge3" class="edge"&gt;&lt;title&gt;d&amp;#45;&amp;gt;c&lt;/title&gt;&lt;path fill="none" stroke="black" d="M222.54,-73.1159C213.062,-64.0273 200.997,-52.458 190.457,-42.3513"/&gt;&lt;polygon fill="black" stroke="black" points="192.751,-39.702 183.111,-35.307 187.906,-44.7545 192.751,-39.702"/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class="rb"&gt;task :mail_daily_leader_boards =&amp;gt; :update_leader_boards do
  User.mail_leader_boards!
end

task :flush_data =&amp;gt; :environment do
  Leaderboard.flush!
end

task :update_leader_boards =&amp;gt; :environment do
  Leaderboard.update!
end

task :environment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run &lt;code&gt;mail_daily_leaderboards&lt;/code&gt; it makes sure that &lt;code&gt;update_leader_boards&lt;/code&gt; is run first.  This in turn depends upon &lt;code&gt;environment&lt;/code&gt;, and Rake makes sure that all dependancies are met before executing the task.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake mail_daily_leaderboards --dry-run
** Invoke mail_daily_leader_boards (first_time)
** Invoke update_leader_boards (first_time)
** Invoke environment (first_time)
** Execute (dry run) environment
** Execute (dry run) update_leader_boards
** Execute (dry run) mail_daily_leader_boards
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rake is also smart enough to only run a task once.  Lets look at what happens when we try to run two tasks:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake flush_data mail_daily_leader_boards --dry-run
** Invoke flush_data (first_time)
** Invoke environment (first_time)
** Execute (dry run) environment
** Execute (dry run) flush_data
** Invoke mail_daily_leader_boards (first_time)
** Invoke update_leader_boards (first_time)
** Invoke environment 
** Execute (dry run) update_leader_boards
** Execute (dry run) mail_daily_leader_boards
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice here that even though &lt;code&gt;update_leader_boards&lt;/code&gt; and &lt;code&gt;flush_data&lt;/code&gt; both depend on &lt;code&gt;environment&lt;/code&gt;, so it needs to be run for either of the dependant tasks to run, and it is only invoked once.&lt;/p&gt;

&lt;p&gt;So far so good.&lt;/p&gt;

&lt;h2 id="dataflow-programming"&gt;Dataflow programming&lt;/h2&gt;

&lt;p&gt;So Rake gives us a dependancy specification and resolution process.  We can visualize this in two ways.  One way is where the arrows are pointing to sub tasks, top down, where the arrow direction represents the control flow control of the process.  When you want A, it makes sure that B and C are there, which in turn have their own dependancies.&lt;/p&gt;

&lt;p&gt;What does it mean if we were to reverse the arrows on the graph?&lt;/p&gt;

&lt;table class="table table-bordered"&gt;
  &lt;tr&gt;
    &lt;th style="text-align: center"&gt;Top Down&lt;/th&gt;
    &lt;th style="text-align: center"&gt;Bottom Up&lt;/th&gt;
  &lt;/tr&gt;

  &lt;tr&gt;
    &lt;td style="text-align: center"&gt;
&lt;svg width="134pt" height="188pt" viewBox="0.00 0.00 134.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"&gt;&lt;title&gt;%3&lt;/title&gt;&lt;polygon fill="white" stroke="none" points="-4,4 -4,-184 130,-184 130,4 -4,4"/&gt;&lt;!-- A --&gt;&lt;g id="node1" class="node"&gt;&lt;title&gt;A&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="63" cy="-162" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="63" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;A&lt;/text&gt;&lt;/g&gt;&lt;!-- B --&gt;&lt;g id="node2" class="node"&gt;&lt;title&gt;B&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;B&lt;/text&gt;&lt;/g&gt;&lt;!-- A&amp;#45;&amp;gt;B --&gt;&lt;g id="edge1" class="edge"&gt;&lt;title&gt;A&amp;#45;&amp;gt;B&lt;/title&gt;&lt;path fill="none" stroke="black" d="M54.6504,-144.765C50.2885,-136.283 44.8531,-125.714 39.9587,-116.197"/&gt;&lt;polygon fill="black" stroke="black" points="42.9904,-114.439 35.3043,-107.147 36.7654,-117.641 42.9904,-114.439"/&gt;&lt;/g&gt;&lt;!-- C --&gt;&lt;g id="node3" class="node"&gt;&lt;title&gt;C&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;C&lt;/text&gt;&lt;/g&gt;&lt;!-- A&amp;#45;&amp;gt;C --&gt;&lt;g id="edge2" class="edge"&gt;&lt;title&gt;A&amp;#45;&amp;gt;C&lt;/title&gt;&lt;path fill="none" stroke="black" d="M71.3496,-144.765C75.7115,-136.283 81.1469,-125.714 86.0413,-116.197"/&gt;&lt;polygon fill="black" stroke="black" points="89.2346,-117.641 90.6957,-107.147 83.0096,-114.439 89.2346,-117.641"/&gt;&lt;/g&gt;&lt;!-- D --&gt;&lt;g id="node4" class="node"&gt;&lt;title&gt;D&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;D&lt;/text&gt;&lt;/g&gt;&lt;!-- B&amp;#45;&amp;gt;D --&gt;&lt;g id="edge3" class="edge"&gt;&lt;title&gt;B&amp;#45;&amp;gt;D&lt;/title&gt;&lt;path fill="none" stroke="black" d="M27,-71.6966C27,-63.9827 27,-54.7125 27,-46.1124"/&gt;&lt;polygon fill="black" stroke="black" points="30.5001,-46.1043 27,-36.1043 23.5001,-46.1044 30.5001,-46.1043"/&gt;&lt;/g&gt;&lt;!-- C&amp;#45;&amp;gt;D --&gt;&lt;g id="edge4" class="edge"&gt;&lt;title&gt;C&amp;#45;&amp;gt;D&lt;/title&gt;&lt;path fill="none" stroke="black" d="M84.4297,-74.8345C74.2501,-64.9376 60.4761,-51.5462 48.9694,-40.3591"/&gt;&lt;polygon fill="black" stroke="black" points="51.4055,-37.8461 41.7957,-33.3847 46.5259,-42.865 51.4055,-37.8461"/&gt;&lt;/g&gt;&lt;!-- E --&gt;&lt;g id="node5" class="node"&gt;&lt;title&gt;E&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-18" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;E&lt;/text&gt;&lt;/g&gt;&lt;!-- C&amp;#45;&amp;gt;E --&gt;&lt;g id="edge5" class="edge"&gt;&lt;title&gt;C&amp;#45;&amp;gt;E&lt;/title&gt;&lt;path fill="none" stroke="black" d="M99,-71.6966C99,-63.9827 99,-54.7125 99,-46.1124"/&gt;&lt;polygon fill="black" stroke="black" points="102.5,-46.1043 99,-36.1043 95.5001,-46.1044 102.5,-46.1043"/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;    &lt;/td&gt;

    &lt;td style="text-align: center"&gt;
&lt;svg width="134pt" height="188pt" viewBox="0.00 0.00 134.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"&gt;&lt;title&gt;%3&lt;/title&gt;&lt;polygon fill="white" stroke="none" points="-4,4 -4,-184 130,-184 130,4 -4,4"/&gt;&lt;!-- E --&gt;&lt;g id="node1" class="node"&gt;&lt;title&gt;E&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-162" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;E&lt;/text&gt;&lt;/g&gt;&lt;!-- C --&gt;&lt;g id="node2" class="node"&gt;&lt;title&gt;C&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;C&lt;/text&gt;&lt;/g&gt;&lt;!-- E&amp;#45;&amp;gt;C --&gt;&lt;g id="edge1" class="edge"&gt;&lt;title&gt;E&amp;#45;&amp;gt;C&lt;/title&gt;&lt;path fill="none" stroke="black" d="M27,-143.697C27,-135.983 27,-126.712 27,-118.112"/&gt;&lt;polygon fill="black" stroke="black" points="30.5001,-118.104 27,-108.104 23.5001,-118.104 30.5001,-118.104"/&gt;&lt;/g&gt;&lt;!-- A --&gt;&lt;g id="node5" class="node"&gt;&lt;title&gt;A&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="63" cy="-18" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="63" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;A&lt;/text&gt;&lt;/g&gt;&lt;!-- C&amp;#45;&amp;gt;A --&gt;&lt;g id="edge4" class="edge"&gt;&lt;title&gt;C&amp;#45;&amp;gt;A&lt;/title&gt;&lt;path fill="none" stroke="black" d="M35.3496,-72.7646C39.7115,-64.2831 45.1469,-53.7144 50.0413,-44.1974"/&gt;&lt;polygon fill="black" stroke="black" points="53.2346,-45.6409 54.6957,-35.1473 47.0096,-42.4395 53.2346,-45.6409"/&gt;&lt;/g&gt;&lt;!-- D --&gt;&lt;g id="node3" class="node"&gt;&lt;title&gt;D&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-162" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;D&lt;/text&gt;&lt;/g&gt;&lt;!-- D&amp;#45;&amp;gt;C --&gt;&lt;g id="edge2" class="edge"&gt;&lt;title&gt;D&amp;#45;&amp;gt;C&lt;/title&gt;&lt;path fill="none" stroke="black" d="M84.4297,-146.834C74.2501,-136.938 60.4761,-123.546 48.9694,-112.359"/&gt;&lt;polygon fill="black" stroke="black" points="51.4055,-109.846 41.7957,-105.385 46.5259,-114.865 51.4055,-109.846"/&gt;&lt;/g&gt;&lt;!-- B --&gt;&lt;g id="node4" class="node"&gt;&lt;title&gt;B&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;B&lt;/text&gt;&lt;/g&gt;&lt;!-- D&amp;#45;&amp;gt;B --&gt;&lt;g id="edge3" class="edge"&gt;&lt;title&gt;D&amp;#45;&amp;gt;B&lt;/title&gt;&lt;path fill="none" stroke="black" d="M99,-143.697C99,-135.983 99,-126.712 99,-118.112"/&gt;&lt;polygon fill="black" stroke="black" points="102.5,-118.104 99,-108.104 95.5001,-118.104 102.5,-118.104"/&gt;&lt;/g&gt;&lt;!-- B&amp;#45;&amp;gt;A --&gt;&lt;g id="edge5" class="edge"&gt;&lt;title&gt;B&amp;#45;&amp;gt;A&lt;/title&gt;&lt;path fill="none" stroke="black" d="M90.6504,-72.7646C86.2885,-64.2831 80.8531,-53.7144 75.9587,-44.1974"/&gt;&lt;polygon fill="black" stroke="black" points="78.9904,-42.4395 71.3043,-35.1473 72.7654,-45.6409 78.9904,-42.4395"/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;If we think about rake in terms of managing a build process, what we called &lt;em&gt;dependancies&lt;/em&gt; are actually the source of the data.  If we want an object file, we start with the source file.  If we want to generate C, we need to have generated the data for D and E.&lt;/p&gt;

&lt;h2 id="file-tasks"&gt;File Tasks&lt;/h2&gt;

&lt;p&gt;Rake also knows about building files.  &lt;code&gt;Rake::FileTask&lt;/code&gt; is a subtask of &lt;code&gt;Rake::Task&lt;/code&gt; which will only run the target if the &lt;em&gt;file is out of date&lt;/em&gt; : if the source file is newer than the destination file.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;file &amp;quot;Rakefile.gz&amp;quot; =&amp;gt; &amp;quot;Rakefile&amp;quot; do |task|
  sh &amp;quot;gzip -fkv #{task.source}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defined as task called &lt;code&gt;Rakefile.gz&lt;/code&gt; that when invoked will look to see if either the file doesn&amp;#39;t exist, or if it&amp;#39;s older than the source file &lt;code&gt;Rakefile&lt;/code&gt;, and gzips it up.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake Rakefile.gz
gzip -fkv Rakefile
Rakefile:   -20.6% -- replaced with Rakefile.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run it again and nothing happens!&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake Rakefile.gz
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Touch the source file and it gets rebuilt:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ touch Rakefile
$ rake Rakefile.gz
gzip -fkv Rakefile
Rakefile:   -20.6% -- replaced with Rakefile.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="rake-as-a-build-system"&gt;Rake as a build system&lt;/h2&gt;

&lt;p&gt;Files and rules come from Rake&amp;#39;s &lt;code&gt;make&lt;/code&gt; heritage.  We can think of regular &lt;code&gt;Task&lt;/code&gt;s as being a general sort of &lt;em&gt;action&lt;/em&gt;, meaning you are packaging up certain set of imperitives in a particular context to achieve some goal.  &lt;code&gt;FileTask&lt;/code&gt;s are a more specific type of action, where we want to generate a specific file from a specific source file.  For a full build system we want to be able to translate whole classes of files into other files, like source files into object files, or XML files into HTML files.  We use &lt;code&gt;Rules&lt;/code&gt; to set these up.&lt;/p&gt;

&lt;h2 id="tasks-defined-as-rules"&gt;Tasks defined as Rules&lt;/h2&gt;

&lt;p&gt;The third main bit of magic that Rake gives us is rules.  The file task can magically bring a file into being when invoked, but in a build process its more common to translate files with a certain extention to other files in a different extension.  The canonical example is probably compiling &lt;code&gt;.c&lt;/code&gt; source files into &lt;code&gt;.o&lt;/code&gt; objects, but since it&amp;#39;s the 21 first century lets look at how to run the Graphviz dot file to process into svg or png files.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;rule &amp;quot;.svg&amp;quot; =&amp;gt; &amp;quot;.dot&amp;quot; do |task|
  sh &amp;quot;dot -Tsvg &amp;lt; #{task.source} &amp;gt; #{task}&amp;quot;
end

rule &amp;quot;.png&amp;quot; =&amp;gt; &amp;quot;.dot&amp;quot; do |task|
  sh &amp;quot;dot -Tpng &amp;lt; #{task.source} &amp;gt; #{task}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can ask Rake to build a &lt;em&gt;type&lt;/em&gt; of file, and will look for a source file based upon the name that you request.  For example, if we were to run the command:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake bottom.svg
dot -Tsvg &amp;lt; bottom.dot &amp;gt; bottom.svg
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rake would try to instantiate the file &lt;code&gt;bottom.svg&lt;/code&gt; by first requesting file called &lt;code&gt;bottom.dot&lt;/code&gt;.  Since this is part of the rake dependancy system, this could in turn be built by a seperate rake task!&lt;/p&gt;

&lt;p&gt;Note that Rake doesn&amp;#39;t know anything specifically about these extension.  It just knows what you have defined.  We can define other formats and build rules around that.&lt;/p&gt;

&lt;h2 id="using-rake-to-pull-data-from-a-url"&gt;Using Rake to pull data from a url&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s extend the Rake DSL to be able to download files from the internet.  You can put this at the top of your &lt;code&gt;Rakefile&lt;/code&gt; for now.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;def url( dest, source )
  file dest do
    puts &amp;quot;Loading #{source}&amp;quot;
    if !File.exists?( dest )
      mkdir_p dest.to_s.pathmap( &amp;quot;%d&amp;quot; )
      sh &amp;quot;curl -L &amp;#39;#{source}&amp;#39; &amp;gt; #{dest}&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets use this to download a file from the internet do we can parse it.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;url &amp;quot;source/weather.json&amp;quot;, &amp;quot;http://api.openweathermap.org/data/2.5/weather?id=5128581&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run &lt;code&gt;rake source/weather.json&lt;/code&gt; the first time, the file is downloaded.  The second time we run the rake command nothing happens since the &lt;code&gt;source/weather.json&lt;/code&gt; file already exists.  Lets add a quick task to parse the JSON.&lt;/p&gt;

&lt;h2 id="parse-json-using-simple-ruby-commands"&gt;Parse JSON using simple ruby commands&lt;/h2&gt;

&lt;p&gt;Lets parse the file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;json&amp;#39;
file &amp;quot;report.txt&amp;quot; =&amp;gt; &amp;quot;source/weather.json&amp;quot; do |task|
  puts &amp;quot;Parsing sun times&amp;quot;
  data = JSON.parse( File.read( task.source ))
  File.open( task.to_s, &amp;quot;wb&amp;quot; ) do |out|
    out.printf &amp;quot;%-15s %s\n&amp;quot;, &amp;#39;sunrise&amp;#39;, Time.at( data[&amp;#39;sys&amp;#39;][&amp;#39;sunrise&amp;#39;] )
    out.printf &amp;quot;%-15s %s\n&amp;quot;, &amp;#39;sunset&amp;#39;,  Time.at( data[&amp;#39;sys&amp;#39;][&amp;#39;sunset&amp;#39;] )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run &lt;code&gt;rake report.txt&lt;/code&gt;.  This should generate the file the first time, and on subsequent runs, do nothing.  If you remove &lt;code&gt;source/weather.json&lt;/code&gt; file and run &lt;code&gt;rake report.txt&lt;/code&gt; again, you&amp;#39;ll see that Rake is smart enough to download a new version of the file.&lt;/p&gt;

&lt;h2 id="parsing-html"&gt;Parsing HTML&lt;/h2&gt;

&lt;p&gt;Another common thing to do is to download a webpage and parse through the results.  &lt;code&gt;Nokogiri&lt;/code&gt; makes this really easy since you can identify DOM elements using CSS selectors more or less the same a jQuery selectors.&lt;/p&gt;

&lt;p&gt;Lets make a function to help us parse html files into CSV files:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Parse an HTML file into CSV
def parse_html( dest, source, &amp;amp;parser )
  require &amp;#39;nokogiri&amp;#39;
  require &amp;#39;csv&amp;#39;

  file dest =&amp;gt; source do
    puts &amp;quot;Parsing #{source} -&amp;gt; #{dest}&amp;quot;
    mkdir_p dest.to_s.pathmap( &amp;quot;%d&amp;quot; )

    html = Nokogiri.parse( File.read( source ) )
    CSV.open( dest.to_s, &amp;quot;wb&amp;quot; ) do |csv|
      parser.call( html, csv )
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines a file task to convert one file type into another.  When it needs to run -- and this will only happen of the source file changes or the destination file doesnt exist -- it loads up the file into Nokogiri, creates a CSV output file, and passes control to a passed in block for processing.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s pull out a list of the top 10 popular books on project gutenberg for the last month:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Load the html file with statistics
url &amp;quot;source/top.html&amp;quot;, &amp;quot;http://www.gutenberg.org/browse/scores/top&amp;quot;

parse_html &amp;quot;processed/month_top_100.csv&amp;quot;, &amp;quot;source/top.html&amp;quot; do |html,out|
  html.css( &amp;quot;h2#books-last30 + ol a&amp;quot; ).each do |link|
    out &amp;lt;&amp;lt; [link[&amp;#39;href&amp;#39;],link.content]
  end
end

file &amp;quot;processed/month_top_10.csv&amp;quot; =&amp;gt; &amp;quot;processed/month_top_100.csv&amp;quot; do |task|
  sh &amp;quot;head -n 10 #{task.source} &amp;gt; #{task}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now run &lt;code&gt;rake processed/month_top_10.csv&lt;/code&gt; and watch what happens.  This only hits the server the first time it&amp;#39;s run.  If we want to process things again, we simply delete the files in the &lt;code&gt;source&lt;/code&gt; directory and everything in the &lt;code&gt;processed&lt;/code&gt; directory will get regenerated.&lt;/p&gt;

&lt;h2 id="tasks-over-multiple-files"&gt;Tasks over multiple files&lt;/h2&gt;

&lt;p&gt;We have a few CSV files that contain a list of books.  How would we do something with these books?  The natural thing would be to use Rake&amp;#39;s &lt;code&gt;FileList&lt;/code&gt;, but this doesn&amp;#39;t work the way you&amp;#39;d expect because &lt;code&gt;FileList&lt;/code&gt; caches its results and it therefor doesn&amp;#39;t know about files that are created during the build process.  We don&amp;#39;t want to have to run rake twice to get our results, we want to be able to trust the process!&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s extend the DSL again to add a command that will loop over a file and call our block for each line:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Loop over a file and yield the block for each line
# If name ends with .csv, parse the csv and yield each line
def file_loop( name, source )
  task name =&amp;gt; source do
    if source =~ /.csv$/
      CSV.open( source ).each do |line|
        yield line
      end
    else
      File.readlines( source ).each do |line|
        yield line
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can use this to create a task that goes through each of the lines of the file.  We&amp;#39;ll do this to define url tasks for the file and then immediately invoke them so make sure that the file was loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Loop through the top ten books and make sure that they exist
file_loop &amp;quot;processed/top_10_books_text&amp;quot;, &amp;quot;processed/month_top_10.csv&amp;quot; do |line|
  path = &amp;quot;#{line[0].gsub( /^\//, &amp;quot;&amp;quot; )}.txt&amp;quot;
  puts path
  url( path, &amp;quot;http://www.gutenberg.org/#{path}.utf-8&amp;quot;)
  Rake::Task[path].invoke
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;code&gt;rake processed/top_10_books_text&lt;/code&gt; will first make sure that &lt;code&gt;processed/month_top_10.csv&lt;/code&gt; is up-to-date, doing whatever it needs too to make it happen, and then loop through each of the lines and download the ebook file.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note, we are going to be making a bunch of requests to the Project Gutenberg website, a total of 11 in all.  You might be flagged as a bot, so take a look at the generated &lt;code&gt;.txt&lt;/code&gt; files to make sure that they actually contain the book content. &lt;strong&gt;But no matter how many times you run your commands, unless you delete the downloaded files there will be no more than 11 requests to the server!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id="using-rules-to-parse-data"&gt;Using rules to parse data&lt;/h2&gt;

&lt;p&gt;Lets create a rule that will give us a count of all the words in a book:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Count and sort the list of words
rule &amp;quot;.word_count&amp;quot; =&amp;gt; &amp;quot;.words&amp;quot; do |dest|
  sh &amp;quot;cat #{dest.source} | sort | uniq -c | sort -nr&amp;gt; #{dest}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we try to run this now, say &lt;code&gt;rake ebooks/1342.word_count&lt;/code&gt; we&amp;#39;ll get an error saying it doesn&amp;#39;t know how to build that file.  Let&amp;#39;s add a rule to go from &lt;code&gt;.txt&lt;/code&gt; to &lt;code&gt;.words&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Covert txt to words
rule &amp;quot;.words&amp;quot; =&amp;gt; &amp;quot;.txt&amp;quot; do |dest|
  sh &amp;quot;cat #{dest.source} | tr -cs &amp;#39;[:alpha:]&amp;#39; &amp;#39;\n&amp;#39; | tr &amp;#39;[:upper:]&amp;#39; &amp;#39;[:lower:]&amp;#39; &amp;gt; #{dest}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we run it, we first generate a list of words, and then from that we find the unique count of them.&lt;/p&gt;

&lt;h2 id="get-your-own-rake-data"&gt;Get your own rake-data&lt;/h2&gt;

&lt;p&gt;It&amp;#39;s simple enough to setup this on your own, but I&amp;#39;ve put together a few useful things that I&amp;#39;ve been using to process data into it&amp;#39;s own gem.  You should head over to &lt;a href="https://github.com/HappyFunCorp/rake-data"&gt;https://github.com/HappyFunCorp/rake-data&lt;/a&gt; now to check it out!&lt;/p&gt;

&lt;p&gt;Other things to check out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.kaggle.com/2012/10/15/make-for-data-scientists/"&gt;http://blog.kaggle.com/2012/10/15/make-for-data-scientists/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.factual.com/introducing-drake-a-kind-of-make-for-data"&gt;http://blog.factual.com/introducing-drake-a-kind-of-make-for-data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://datascienceatthecommandline.com"&gt;http://datascienceatthecommandline.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Building Middleman Extensions</title>
    <link rel="alternate" href="http://willschenk.com/building-middleman-extensions/"/>
    <id>http://willschenk.com/building-middleman-extensions/</id>
    <published>2014-12-16T19:00:00-05:00</published>
    <updated>2014-12-16T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Middleman extensions, like rails plugins, are packaged as gems.  There are three main ways to extend middleman.  You can add helpers, add middleman commands, or extend the sitemap generation in someway.  Lets go through those in detail.&lt;/p&gt;

&lt;h2 id="creating-the-extension"&gt;Creating the extension&lt;/h2&gt;

&lt;p&gt;Create a gem using &lt;code&gt;bundle gem _name_&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle gem middleman-graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;middleman-core&lt;/code&gt; to your gem dependancies in the &lt;code&gt;.gemspec&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  spec.add_runtime_dependency     &amp;#39;middleman-core&amp;#39;, [&amp;#39;&amp;gt;= 3.0.0&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Register your extension into middleman.  Our gem will be activated in the sites &lt;code&gt;config.rb&lt;/code&gt; using &lt;code&gt;activate :graphviz&lt;/code&gt; and this is how middleman knows what to load.  &lt;code&gt;lib/middleman/graphviz.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman-core&amp;#39;
require &amp;quot;middleman/graphviz/version&amp;quot;
require &amp;quot;middleman/graphviz/extension&amp;quot;

::Middleman::Extensions.register(:graphviz, ::Middleman::Graphviz::Extension )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Replace with your gem name!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Write the code that actually plugs into middleman.  The we are going to add some helpers to the site, so let&amp;#39;s register them here.  Create &lt;code&gt;lib/middleman/graphviz/extension.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman/graphviz/helpers&amp;#39;

module Middleman
  module Graphviz
    class Extension &amp;lt; Middleman::Extension
      def initialize( app, options_hash = {}, &amp;amp;block)
        super

        app.helpers Middleman::Graphviz::Helpers
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Replace with your gem name!&lt;/em&gt;&lt;/p&gt;

&lt;h2 id="writing-helpers"&gt;Writing helpers&lt;/h2&gt;

&lt;p&gt;Lets create a basic helper method now in the file &lt;code&gt;lib/middleman/graphviz/helpers.rb&lt;/code&gt;. This is going to accept one parameter and a block. We are going to get the content of that block and then spit it back directly for now.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module Middleman
  module Graphviz
    module Helpers
      def basic_helper_example( param )
        &amp;quot;&amp;lt;h1&amp;gt;#{param}&amp;lt;/h1&amp;gt;&amp;quot;.html_safe
      end

      def block_helper_example( type, &amp;amp;block )
        if block_given?
          data = capture_html(&amp;amp;block)

          data = data.upcase

          concat_content(data.html_safe)
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These can be used like&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%%= basic_helper_example( &amp;quot;My Title&amp;quot;) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a block&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%% block_helper( &amp;quot;My Title&amp;quot;) do %&amp;gt;
  This is going to be in upcase
&amp;lt;%% end %%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="add-it-to-an-active-middleman-project"&gt;Add it to an active middleman project&lt;/h2&gt;

&lt;p&gt;Have bundler reference this new gem inside of an existing middleman project.  &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;quot;middleman-graphviz&amp;quot;, path: &amp;quot;../middleman-graphviz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside of the middleman project&amp;#39;s &lt;code&gt;config.rb&lt;/code&gt; activate it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;activate :graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now startup the middleman server, and use your helper in the page!  Note that, just like when you use a helper defined in &lt;code&gt;config.rb&lt;/code&gt; you need to restart &lt;code&gt;middleman server&lt;/code&gt; to see your change take effect.&lt;/p&gt;

&lt;h2 id="adding-configuration-to-your-extension"&gt;Adding configuration to your extension&lt;/h2&gt;

&lt;p&gt;If you want to include configurable options in your extension, here&amp;#39;s some skeleton code for &lt;code&gt;extension.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman/graphviz/helpers&amp;#39;

module Middleman
  module Graphviz
    cattr_accessor :options

    class Extension &amp;lt; Middleman::Extension
      def initialize( app, options_hash = {}, &amp;amp;block)
        super

        app.helpers Middleman::Graphviz::Helpers
      end

      def registered(app, options_hash = {}, &amp;amp;block)
        options = Options.new(options_hash)
        yield options if block_given?

        # Default options for the rsync method.
        options.theme ||= &amp;quot;default&amp;quot;
        options.generate_file ||= false

        ::Middleman::Graphviz.options = options

        app.helpers Middleman::Graphviz::Helpers
      end

      def after_configuration
        puts &amp;quot;After configuration&amp;quot;
      end
    end

    module Helpers
      def options
        ::Middleman::Graphviz.options
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="adding-additional-middleman-commands"&gt;Adding additional middleman commands&lt;/h2&gt;

&lt;p&gt;The middleman command is built on &lt;a href="/making-a-command-line-utility-with-gems-and-thor"&gt;thor&lt;/a&gt;, which as we know is awesome.  To add a command to the middleman, use the following template for each &lt;code&gt;command.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman-core/cli&amp;#39;

module Middleman
  module Cli
    # This class provides a &amp;quot;deploy&amp;quot; command for the middleman CLI.
    class Graphviz &amp;lt; Thor
      include Thor::Actions

      check_unknown_options!

      namespace :graphviz

      # Tell Thor to exit with a nonzero exit code on failure
      def self.exit_on_failure?
        true
      end

      desc &amp;#39;graphviz [options]&amp;#39;, &amp;#39;Run this amazing command&amp;#39;
      method_option &amp;#39;clean&amp;#39;,
        type: :boolean,
        aliases: &amp;#39;-c&amp;#39;,
        desc: &amp;#39;Clean all the build files&amp;#39;
      def graphviz
        @shared_instance = ::Middleman::Application.server.inst

        puts &amp;quot;Running my command&amp;quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, inside of &lt;code&gt;middleman/graphviz.rb&lt;/code&gt; simply &lt;code&gt;require &amp;#39;middleman/graphviz/command&amp;#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href="http://www.rubydoc.info/github/wycats/thor/Thor/Actions"&gt;&lt;code&gt;Thor::Actions&lt;/code&gt;&lt;/a&gt; class gives you access to many different helper commands that make it easy to move, filter, template, and otherwise mangle files, and of course you have access to the full middleman app.&lt;/p&gt;

&lt;h2 id="manipulating-the-sitemap"&gt;Manipulating the sitemap&lt;/h2&gt;

&lt;p&gt;The most awesomest way to extend middleman is by modifying the sitemap.  This lets us create whole new URLs that are derived and generated from other sources.  This is how the &lt;a href="https://github.com/middleman/middleman-blog"&gt;middleman-blog&lt;/a&gt; extension really works, and if you want to start an indepth exploration that&amp;#39;s a good place to start spelunking.&lt;/p&gt;

&lt;p&gt;Lets build an extesion that creates pages from an external datasource.  In this case, a CSV file, but you could imagine having this come out of a database instead.  This lets us manipulate the sitemap of the site it&amp;#39;s been created, and will let us add and remove different pages based upon what middleman knows about the site.&lt;/p&gt;

&lt;p&gt;First we add an &lt;code&gt;after_configuration&lt;/code&gt; handler to &lt;code&gt;Middleman::Graphviz::Extension&lt;/code&gt; to register our class as a &lt;code&gt;resource_list_manipulator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def after_configuration
    @csv_pages = Middleman::CSV::Page.new( @app, self )
    @app.sitemap.register_resource_list_manipulator(:&amp;quot;csv_pages&amp;quot;, @csv_pages, false)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we create &lt;code&gt;lib/middleman/csv/page.rb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;csv&amp;#39;

module Middleman
  module CSV
    class Page
      # include UriTemplates

      def initialize(app, controller)
        @sitemap = app.sitemap
        @page_link_template = &amp;quot;pages/{page}.html&amp;quot;
        @page_template = &amp;quot;page.html&amp;quot;
        app.ignore @page_template
      end

      # Update the main sitemap resource list
      # @return [void]
      def manipulate_resource_list(resources)
        resources + ::CSV.open( &amp;quot;pages.csv&amp;quot; ).collect do |row|
          create_page_resource( row[0], row )
        end
      end

      private

      def link(page)
        ::Middleman::Util.normalize_path @page_link_template.gsub( /\{page\}/, page )
      end

      def create_page_resource( page, row )
        Sitemap::Resource.new(@sitemap, link(page)).tap do |p|
          p.proxy_to( @page_template )

          p.add_metadata locals: {
            row: row
          }
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;initialized&lt;/code&gt; is called, we are grabbing references to the middleman app.  We&amp;#39;ve hard coded two things in this example that should be from the options, the page name template, and the page template itself.  Since the &lt;code&gt;page.html&lt;/code&gt; isn&amp;#39;t meant to be standalone, we tell middleman to ignore it in the sitemap with &lt;code&gt;app.ignore @page_template&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;manipulate_resource_list&lt;/code&gt; is called it is passed a list of resources that middleman currently knows about.  We return a new list of resources based on that list.  What we are doing in this example is loading up the list of pages from a file called &lt;code&gt;pages.csv&lt;/code&gt;, creating new pages based on that, and then returning the new list.&lt;/p&gt;

&lt;p&gt;This example is contrived and we are loading in the list of pages from the filesystem.  At this point in the rendering process we do have access to all of the pages, instead of loading up a file you could inspect the site map, go through all of the pages and make additional pages for subsets of those.  The &lt;code&gt;middleman-blog&lt;/code&gt; does this for both &lt;code&gt;tag&lt;/code&gt; pages and &lt;code&gt;calendar&lt;/code&gt; pages.  Instead of calling &lt;code&gt;::CSV.open&lt;/code&gt; it goes through all of the pages on the site and collects a dynamic list of pages based upon the metatag, either &lt;code&gt;tag&lt;/code&gt; or published dates.&lt;/p&gt;

&lt;p&gt;Then we create the entries in the sitemap themselves. These first get proxied to our page template.  Then we set the metadata of the particular page to be what we loaded in from the file.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s an example template &lt;code&gt;page.html.haml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;%h1= row[1]
= row[0] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is equivelent to looping over a file in &lt;code&gt;config.rb&lt;/code&gt; and setting up page proxies there.  However in that case we don&amp;#39;t have access to the sitemap overall, so we couldn&amp;#39;t generate a dynamic list of new pages based upon existing pages.  With this extension we can insert ourselves into the rendering process and add the &lt;em&gt;awesome&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Building these extensions is a very complicated way to achive things that would be simplier if you just build the site in rails and had a database with you at runtime.  But it works, and you can achieve plug into the rendering process to create a more &lt;em&gt;dynamic&lt;/em&gt; static site.  Helpers are by far the easiest way to package things together, and as you can see from the example I&amp;#39;m working through I&amp;#39;m working on an easy way to integrate Graphviz images in middleman documents without a seperate workflow.  (&lt;em&gt;Coming soon.&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Middleman CLI commands are also easy to build, though here you do start to need to know more about how the internals of how middleman is setup.  Things like the &lt;code&gt;middleman-deploy&lt;/code&gt; gem are pretty amazing and can really help with the overall publishing workflow.&lt;/p&gt;

&lt;p&gt;And sitemap manipulation is the most powerful, which lets you recreate pages based upon site and page metadata that is collected throughout the process.  The entire &lt;code&gt;middleman-blog&lt;/code&gt; extention is build using this functionality.&lt;/p&gt;

&lt;p&gt;Happy building!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Middleman Tricks and Hacks</title>
    <link rel="alternate" href="http://willschenk.com/middleman-tricks-and-hacks/"/>
    <id>http://willschenk.com/middleman-tricks-and-hacks/</id>
    <published>2014-12-12T19:00:00-05:00</published>
    <updated>2014-12-12T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;As part of the process of getting this site to work, I learned some more things about how to better build a site with middleman.  Building off of our &lt;a href="/building-sites-with-middleman/"&gt;foundational article&lt;/a&gt; here are a few other things that I found very useful when using middleman to build a static site with a bunch of dynamically generated content.&lt;/p&gt;

&lt;h2 id="partials"&gt;Partials&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;index.html.haml&lt;/code&gt;, &lt;code&gt;articles.html.haml&lt;/code&gt;, &lt;code&gt;tag.html.haml&lt;/code&gt; and &lt;code&gt;calendar.html.haml&lt;/code&gt; pages all use the same partial to list out the post archives, which are mostly the same.&lt;/p&gt;

&lt;p&gt;On the &lt;em&gt;index&lt;/em&gt; page it&amp;#39;s called like this, where I&amp;#39;m supressing the date heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;= partial &amp;quot;post_list&amp;quot;, :locals =&amp;gt; {:page_articles =&amp;gt; blog.articles[1..4], :no_date =&amp;gt; true }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the &lt;em&gt;articles&lt;/em&gt; I&amp;#39;m including draft posts for my own reference, and since they don&amp;#39;t have a published date we need to check for that.&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;= partial &amp;quot;post_list&amp;quot;, :locals =&amp;gt; {:page_articles =&amp;gt; (drafts + page_articles)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;_post_list.haml&lt;/code&gt; file then has some logic to show date headings based upon the published dates of the articles.  (This assumes that the posts are sorted by time, either ascending or descending.) &lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;- last_date = nil
- no_date = !!no_date
%ul
  - page_articles.each do |current_post|
    - if !no_date &amp;amp;&amp;amp; current_post.date
      - date_string = current_post.date.strftime(&amp;#39;%b %Y&amp;#39;)
      - if last_date != date_string
        %li.date
          %h2= date_string
      - last_date = date_string
    %li
      .more
        - unless current_post.is_a? ::Middleman::Blog::Drafts::DraftArticle
          = current_post.date.strftime( &amp;#39;%b %e&amp;#39; )
        - else
          Draft
      %div= link_to current_post.title, current_post
      %div
        = current_post.data[&amp;#39;subtitle&amp;#39;]

        .tags
          - current_post.tags.sort.each do |tag|
            .tag= link_to tag, tag_path( tag )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Partials also work better when using &lt;a href="/bootstrap-advanced-grid-tricks/"&gt;semantic CSS classes&lt;/a&gt; to define my layouts, since the same class can have different meaning depending upon what it is embedded in.&lt;/p&gt;

&lt;h2 id="layouts-and-partials-for-articles"&gt;Layouts and partials for articles&lt;/h2&gt;

&lt;p&gt;Middleman posts are generally written in markdown, which translates into a series of &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags that are dumped into a layout file.  In order to create the table of contents on the left, the navigation to other articles on the right, the unique header and footer, I used a seperate &lt;code&gt;article_layout&lt;/code&gt; for article pages.  Setting up &lt;strong&gt;Scrollspy&lt;/strong&gt; and &lt;strong&gt;Affix&lt;/strong&gt; means we need to change things on the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag that we don&amp;#39;t need to do for other pages, so it makes more sense to use a seperate file here rather than a &lt;em&gt;nested layout&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This means that all the things that are shared between the two layouts, the main layout for all the meta pages and the article layout for the content pages, should be factored into partials.  I put these partials in the &lt;code&gt;layouts/&lt;/code&gt; directory.&lt;/p&gt;

&lt;h2 id="communication-between-partials"&gt;Communication between partials&lt;/h2&gt;

&lt;p&gt;The top and the bottom of these pages change together.  If the page has a header image -- something I specify in the YAML preamble of my post -- then both the &lt;code&gt;article_header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; partials display slightly different things.  The logic for this check is in the &lt;code&gt;article_header&lt;/code&gt;, where I set a &lt;em&gt;instance variable&lt;/em&gt; that I use in a later partial to add a class.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;layouts/_article_header.haml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- @lighter ||= &amp;quot;&amp;quot;
- @dark_header = &amp;quot;dark_header&amp;quot; if current_article.data[&amp;#39;dark_header&amp;#39;]
- if !current_article.data[&amp;#39;header_image&amp;#39;].nil? &amp;amp;&amp;amp; current_article.data[&amp;#39;header_image&amp;#39;] != &amp;quot;&amp;quot;
  - @lighter = &amp;quot;lighter&amp;quot;
  .banner
    = image_tag current_article.data[&amp;#39;header_image&amp;#39;], class: &amp;quot;fadeInDown animated&amp;quot;

%div{ class: &amp;quot;article-header #{@lighter} #{@dark_header}&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then in &lt;code&gt;layouts/_footer.haml&lt;/code&gt; I use the same variable to add a class to the &lt;code&gt;footer&lt;/code&gt; element which changes the background.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%footer{ class: &amp;quot;footer #{@lighter} #{@dark_header}&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="markdown-with-toc-data"&gt;Markdown with toc data&lt;/h2&gt;

&lt;p&gt;Inside of &lt;code&gt;config.rb&lt;/code&gt; we can add some better markdown processing options.  I switched to redcarpet and enabled &lt;code&gt;with_toc_data&lt;/code&gt;.  This generates id tags on the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; etc elements that we can use as anchors.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;set :markdown, :tables =&amp;gt; true, :autolink =&amp;gt; true, :gh_blockcode =&amp;gt; true, :fenced_code_blocks =&amp;gt; true, with_toc_data: true
set :markdown_engine, :redcarpet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These ids are generated by sanitizing the text between the tags, but &lt;code&gt;redcarpet&lt;/code&gt; only makes things lowercase and changes spaces to underscores, and unfortunately it doesn&amp;#39;t strip out punctuation characters and will result in ids that aren&amp;#39;t valid.  So I had to change my headers, at least until I can take a look at the redcarpet code in more detail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; This looks like it&amp;#39;s fixed in the latest git version of redcarpet, but it hasn&amp;#39;t been released as a gem yet.&lt;/p&gt;

&lt;h2 id="helpers-that-parse-the-source-file"&gt;Helpers that parse the source file&lt;/h2&gt;

&lt;p&gt;Now that we have the anchors in there, we need to generate the links to those anchors.  This can be done by parsing the source file on the article page with a helper.  It&amp;#39;s a poor man&amp;#39;s markdown processor, but it does the job.  This code lives in &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;helpers do
  def chapters( post )
    File.readlines( post.source_file ).collect do |x|
      if x =~ /^##\s(.*)/
        $1
      else
        nil
      end
    end.select { |x| x }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can then use it to generate the list of links:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;%ul.nav.toc
  %li= link_to current_article.title, &amp;quot;#top&amp;quot;
  - chapters( current_article ).each do |chapter|
    %li= link_to chapter, &amp;quot;##{chapter.downcase.gsub( /\s/, &amp;quot;-&amp;quot; )}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="helper-methods-to-do-query-ish-things"&gt;Helper methods to do query-ish things&lt;/h2&gt;

&lt;p&gt;The logic to calculate the &lt;em&gt;next&lt;/em&gt; and &lt;em&gt;previous&lt;/em&gt; articles in the series work using the tag system, and it cycles though all of the tags of the current article to find articles with corresponding tags.  Rather than showing the same article for multiple tags, I wanted to group the tags together if they all pointed to the same article.&lt;/p&gt;

&lt;p&gt;This is the type of logic that would normally be in a rails Model.  Either you&amp;#39;d do it directly out of the database, or you would process the results somehow and return something that was easy to iterate over in the view.&lt;/p&gt;

&lt;p&gt;Moving this code into helper method isolated all of that logic out of the views themselves.&lt;/p&gt;

&lt;h2 id="site-data-as-database"&gt;Site data as database&lt;/h2&gt;

&lt;p&gt;The other thing I wanted to do was to associate additional data with specific tags.  If this was an article, you could put it in the preamble, but since tags are generated dynamically from the article files we need to put them somewhere else.  That place is &lt;code&gt;data/topics.yml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="yml"&gt;---
:howto:
  :title: Howtos
  :desc: In which we go through step by step to achieve a particular goal.
:overview:
  :title: Overviews
  :desc: In which we cover a topic in depth to orient ourselves with the technology.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is referenced in views like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;- data[&amp;#39;topics&amp;#39;].each do |k,d|
  .track
    %h2= link_to d[:title], &amp;quot;/tags/#{k}.html&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This data is also referenced in the tag page as well as the main header.  It&amp;#39;s only stored in one place, which is nice and DRY.  If it got any more complicated than this, where we wanted to filter or sort it in some dynamic way then we implement that code in a helper so it could be shared across the site.&lt;/p&gt;

&lt;h2 id="directory-index-and-url_for"&gt;Directory index and url_for&lt;/h2&gt;

&lt;p&gt;To make pretty urls work in the blog, you need to have &lt;code&gt;activate :directory_indexes&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; &lt;code&gt;activate :blog&lt;/code&gt; in your &lt;code&gt;config.rb&lt;/code&gt; file.  &lt;em&gt;The order of middleman extensions in the config file matter.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The plugin works by changing the way that the &lt;code&gt;link_to&lt;/code&gt; helper works.  If you have a link that&amp;#39;s generated in another way, you should use the &lt;code&gt;url_for&lt;/code&gt; method to make sure that it get&amp;#39;s rewritten.  For example&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;= navbar_item d[&amp;#39;title&amp;#39;], url_for( &amp;quot;/tags/#{topic}.html&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="not-a-lot-of-tradeoffs"&gt;Not a lot of tradeoffs&lt;/h2&gt;

&lt;p&gt;Other than the one issue with redcarpet where I couldn&amp;#39;t control the way that the ids were being generated, there hasn&amp;#39;t been much that I haven&amp;#39;t be able to achieve with a statically generated site.  The implementation is different, but overall most of the time was spent fiddling with the CSS rather than fighting the build system.&lt;/p&gt;

&lt;p&gt;Which is how it should be.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Dateslice: Writing rails extensions</title>
    <link rel="alternate" href="http://willschenk.com/dateslice-writing-rails-extensions/"/>
    <id>http://willschenk.com/dateslice-writing-rails-extensions/</id>
    <published>2014-12-06T19:00:00-05:00</published>
    <updated>2014-12-06T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Ruby on Rails is a very modular framework since the merging with Merb in 2008.  The &lt;em&gt;opinionated conventions&lt;/em&gt; are implemented under using techniques that let you jump in and build your own components, picking and choosing different parts that let you build Rails apps in the same straightforward way you would if using the official modules.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s go through the &lt;a href="https://github.com/HappyFunCorp/dateslices"&gt;&lt;code&gt;dateslices&lt;/code&gt; gem&lt;/a&gt; which I wrote to extend active record so that we could better interact with the &lt;code&gt;group by&lt;/code&gt; sql command when dealing with dates.  Thanks to &lt;a href="https://github.com/mbrookes"&gt;mbrookes&lt;/a&gt; this command now outputs in a format compatible with &lt;a href="http://ankane.github.io/chartkick/"&gt;Chartkick&lt;/a&gt; making it a good tool to use when graphing date related things, say user signups, on an admin panel for your application.&lt;/p&gt;

&lt;h2 id="databases"&gt;Databases&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://guides.rubyonrails.org/active_record_basics.html"&gt;ActiveRecord&lt;/a&gt; is how Rails interacts with the database, this includes both SQL generation, validations, and a whole bunch more.  It creates a startardized interface over the many subtle differences between SQL implementations on different databases.  Date handling and grouping on dymanic terms is one area where databases differer greatly from one another, and when we want to find counts and sums grouped by different dates we need to tune our SQL for the vagaries of switching to different databases.&lt;/p&gt;

&lt;h2 id="keeping-development-the-same-as-production"&gt;Keeping development the same as production&lt;/h2&gt;

&lt;p&gt;I tend to develop locally on Sqlite3 and deploy on Postgres.  When we get into something fancy where we want to use some of the amazing features that Postgres has, like &lt;a href="http://www.postgresql.org/docs/9.2/static/libpq-notify.html"&gt;LISTEN/NOTIFY&lt;/a&gt; or &lt;a href="http://postgresguide.com/sexy/hstore.html"&gt;hstore&lt;/a&gt; , then it makes sense to run a Postgres instance locally.  But most of the time it&amp;#39;s overkill, and I prefer running with Sqlite3 since I just need to checkout the project, run bundle, and I&amp;#39;m in a self contained environment.&lt;/p&gt;

&lt;p&gt;Pub/sub and attribute store are cool enough things to warrant managing a local Postgres instance, grouping by date doesn&amp;#39;t cut it in my book.&lt;/p&gt;

&lt;p&gt;If you do already have a Postgres instance running locally, then you should check out the &lt;a href="https://github.com/ankane/groupdate"&gt;&lt;code&gt;groupdate&lt;/code&gt; gem&lt;/a&gt;, which is better and worse than &lt;code&gt;dateslice&lt;/code&gt;: better because it supports Timezones which is awesome and difficult to solve well and worse because it doesn&amp;#39;t support Sqlite3.&lt;/p&gt;

&lt;h2 id="enter-dataslice"&gt;Enter dataslice&lt;/h2&gt;

&lt;p&gt;Lets first take a look at how the SQL differs between the different databases.  The basic structure is&lt;/p&gt;

&lt;pre&gt;&lt;code class="sql"&gt;select aggregation(aggregation_column), timeslice from table group by timeslice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;aggregation&lt;/code&gt; is one of &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, and &lt;code&gt;avg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aggregation_column&lt;/code&gt; is the column we are counting, summing or averaging.  For counts, normally we do &lt;code&gt;count(*)&lt;/code&gt; but we can also do &lt;code&gt;count(distinct(aggregation_column))&lt;/code&gt; if you only want to count the number of unique occurances.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;timeslice&lt;/code&gt; is the time period that we want to look at.  The basic idea here is that we convert a &lt;code&gt;datetime&lt;/code&gt; to a string with lower precision (getting rid of the seconds, or minutes, or hours, or days) and then group on that string.  We need to select this on the left side of the query, and we also need it as the input of the &lt;code&gt;GROUP BY&lt;/code&gt; on the right.&lt;/p&gt;

&lt;p&gt;For example, if we want to group by day, this is the SQL that we&amp;#39;d need for the 3 different database variants we are targetting:&lt;/p&gt;

&lt;table class="table table-bordered"&gt;
  &lt;tr&gt;&lt;th&gt;Database&lt;/th&gt;&lt;th&gt;Time Slice&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Mysql&lt;/th&gt;&lt;td&gt;&lt;code&gt;DATE_FORMAT(#{column}, '%Y-%m-%d 00:00:00 UTC')&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Sqlite3&lt;/th&gt;&lt;td&gt;&lt;code&gt;strftime( \"%Y-%m-%d 00:00:00 UTC\", #{column} )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Postgres&lt;/th&gt;&lt;td&gt;&lt;code&gt;DATE_TRUNC( 'day' , #{column} )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The different variants can be found in the sourecode for &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/mysql.rb"&gt;mysql&lt;/a&gt;, &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/sqlite.rb"&gt;sqlite&lt;/a&gt;, and &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/postgresql.rb"&gt;Postgres&lt;/a&gt;.  (Notice how Postgres is better here too!)&lt;/p&gt;

&lt;h2 id="our-api"&gt;Our api&lt;/h2&gt;

&lt;p&gt;We want to add &lt;code&gt;group_by_second&lt;/code&gt;, &lt;code&gt;group_by_minute&lt;/code&gt;, &lt;code&gt;group_by_hour&lt;/code&gt;, &lt;code&gt;group_by_day&lt;/code&gt;, &lt;code&gt;group_by_week&lt;/code&gt;, &lt;code&gt;group_by_day_of_week&lt;/code&gt;, &lt;code&gt;group_by_month&lt;/code&gt;, &lt;code&gt;group_by_year&lt;/code&gt; to ActiveRecord classes that we can use either on the model itself:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;User.group_by_day
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or on a scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;Post.unmoderated.group_by_day
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And get a resulting hash back like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;{
      &amp;quot;2014-07-12 00:00:00 UTC&amp;quot; =&amp;gt; 1,
      &amp;quot;2014-07-18 00:00:00 UTC&amp;quot; =&amp;gt; 2,
      &amp;quot;2014-07-19 00:00:00 UTC&amp;quot; =&amp;gt; 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in a &lt;code&gt;rspec&lt;/code&gt; test, something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  it &amp;quot;should return items grouped by day&amp;quot; do
    expect( User.count ).to eq(0)

    @initial_time = Time.parse &amp;quot;2014-07-19 15:26:48 -0400&amp;quot;

    User.create created_at: @initial_time
    User.create created_at: @initial_time - 1.day
    User.create created_at: @initial_time - 1.day
    User.create created_at: @initial_time - 1.week

    expect( User.count ).to eq( 4 )

    res = User.group_by_day( :created_at )

    expect(res).to eq({
      &amp;quot;2014-07-12 00:00:00 UTC&amp;quot; =&amp;gt; 1,
      &amp;quot;2014-07-18 00:00:00 UTC&amp;quot; =&amp;gt; 2,
      &amp;quot;2014-07-19 00:00:00 UTC&amp;quot; =&amp;gt; 1})
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="building-the-rails-extension"&gt;Building the Rails Extension&lt;/h2&gt;

&lt;p&gt;Now that we have an idea of what we want to generate, lets take a look at how we build a rails extension.  This is done with the &lt;code&gt;rails plugin new&lt;/code&gt; command.  We saw the &lt;code&gt;bundle gem&lt;/code&gt; command before back in the &lt;a href="/making-a-command-line-utility-with-gems-and-thor/"&gt;making a command line utility with gems and thor&lt;/a&gt; post, and in many ways they are similar.  But the &lt;code&gt;rails plugin new&lt;/code&gt; command creates a gem setup for a rails environment for testing and developing your app.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/"&gt;Happy Seed&lt;/a&gt; also has a rails plugin generator which will setup rspec testing for you, instead of the default &lt;code&gt;TestUnit&lt;/code&gt;.  This runs the &lt;code&gt;rails plugin new&lt;/code&gt; command which sets up the rails gem environment and does a few other things you need to do to get rspec working correctly, and HappySeed will do that stuff for you.&lt;/p&gt;

&lt;p&gt;Either way, now you have a new folder with an empty gem that we need to fill out.&lt;/p&gt;

&lt;p&gt;We&amp;#39;re going to create a &lt;code&gt;Module&lt;/code&gt;,  &lt;code&gt;Datelices::Scope&lt;/code&gt;, with our methods and then register our methods with the &lt;code&gt;ActiveRecord::Base&lt;/code&gt; class.  This looks like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt; ActiveRecord::Base.send(:extend, Dateslices::Scopes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will mixin our methods into all of the classes that extend &lt;code&gt;ActiveRecord::Base&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="metaprogramming-with-ruby"&gt;Metaprogramming with Ruby&lt;/h2&gt;

&lt;p&gt;Inside of &lt;code&gt;lib/dateslices.rb&lt;/code&gt; lets define all of the fields that we want to define.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module Dateslices
  FIELDS = [:second, :minute, :hour, :day, :week, :day_of_week, :month, :year ]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now inside of &lt;code&gt;lib/dateslices/scopes.rb&lt;/code&gt; we can sketch out our scopes method generator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module Dateslices
  module Scopes
    Dateslices::FIELDS.each do |field|
      define_method :&amp;quot;group_by_#{field}&amp;quot; do |*args|
        # create query based on args, and field
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets go through this for a second.  When this code is evaluated, we are going to loop over &lt;code&gt;Dateslices::FIELDS&lt;/code&gt; and call the &lt;code&gt;define_method&lt;/code&gt; function for each type of grouping.  These are defined inside of the main &lt;code&gt;Dateslices&lt;/code&gt; module, and we are naming our method &lt;code&gt;:&amp;quot;group_by_#{field}&amp;quot;&lt;/code&gt;.  Image that a developer writes &lt;code&gt;User.group_by_day( :updated_at )&lt;/code&gt;, what happens then?&lt;/p&gt;

&lt;p&gt;When that is invoked the Ruby runtime is actually invoking the closure that we are passing into &lt;code&gt;define_method&lt;/code&gt;, which is generated inside of the loop with a different value for &lt;code&gt;field&lt;/code&gt; on each one.  In addition to using this inside of the name of the function, this value is available inside of the body.  The &lt;code&gt;*args&lt;/code&gt; on the other hand, and in our example it would equal &lt;code&gt;[:updated_at]&lt;/code&gt;, comes from the method invocation as we would expect.&lt;/p&gt;

&lt;p&gt;We are writing code which generates code, and some of the variables are part of our desire &amp;quot;not to write 15 of the basically the same methods&amp;quot; and some of the variables are there to tweak the functionality of the API.&lt;/p&gt;

&lt;h2 id="the-sql-bit"&gt;The SQL Bit&lt;/h2&gt;

&lt;p&gt;The full details can be found in &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/scopes.rb"&gt;the repo&lt;/a&gt; but here&amp;#39;s the bit that actually generates the query switching out to the various classes that know how to deal with each of the databases that we saw before.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;args = args.dup

column = args[0].blank? ? &amp;#39;created_at&amp;#39; : args[0]
aggregation = args[1].blank? ? &amp;#39;count&amp;#39; : args[1]
aggregation_column = args[2].blank? ? &amp;#39;*&amp;#39; : args[2]

sql = [&amp;quot;#{aggregation}(#{aggregation_column}) as count&amp;quot;]

time_filter = case connection.adapter_name
                when &amp;#39;SQLite&amp;#39;
                  Dateslices::Sqlite.time_filter(column, field)
                when &amp;#39;PostgreSQL&amp;#39;, &amp;#39;PostGIS&amp;#39;
                  Dateslices::Postgresql.time_filter(column, field)
                when &amp;#39;MySQL&amp;#39;, &amp;#39;Mysql2&amp;#39;
                  Dateslices::Mysql.time_filter(column, field)
                else
                  throw &amp;quot;Unknown database adaptor #{connection.adapter_name}&amp;quot;
              end

sql &amp;lt;&amp;lt; &amp;quot;#{time_filter} as date_slice&amp;quot;

slices = select( sql.join(&amp;#39;, &amp;#39;)).where.not(column =&amp;gt; nil).group(&amp;#39;date_slice&amp;#39;).order(&amp;#39;date_slice&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full code does a bit more to figure out how you want to see the data, but that&amp;#39;s the tricky stuff.&lt;/p&gt;

&lt;h2 id="testing-a-rails-plugin-that-talks-to-many-databases"&gt;Testing a rails plugin that talks to many databases&lt;/h2&gt;

&lt;p&gt;The first thing that&amp;#39;s a little strange when testing a plugin is that you can test your gem in two different contexts: one in a basic ruby context, and your tests go into &lt;code&gt;spec/&lt;/code&gt;, and the other in a rails context.  The plugin generator will create a sample rails app inside of &lt;code&gt;spec/dummy&lt;/code&gt; (or &lt;code&gt;test/dummy&lt;/code&gt; if you are using &lt;code&gt;rails plugin new&lt;/code&gt; without our fancy rspec stuff).  &lt;/p&gt;

&lt;p&gt;Let&amp;#39;s take a look now at how to test a gem that talks to many different databases.  Normally when we start up a rails environment, test or otherwise, it connects to a database and that&amp;#39;s that.  However, we need to run the same test suite over 3 different databases making sure that the gem behaves in exactly the same way for each one.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s our &lt;code&gt;spec/dummy/spec/models/test_spec.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;rails_helper&amp;#39;
require &amp;#39;dateslice_tester&amp;#39;
require &amp;#39;groupdate_tester&amp;#39;

databases = [{ :adapter =&amp;gt; &amp;#39;mysql&amp;#39;, :database =&amp;gt; &amp;#39;dateslice_test&amp;#39;, :user =&amp;gt; &amp;#39;root&amp;#39;},
             { :adapter =&amp;gt; &amp;#39;postgresql&amp;#39;, :database =&amp;gt; &amp;#39;dateslice_test&amp;#39;},
             { :adapter =&amp;gt; &amp;#39;sqlite3&amp;#39;, :database =&amp;gt; &amp;#39;db/test.sqlite3&amp;#39;}]

formats = [&amp;#39;groupdate&amp;#39;, &amp;#39;dateslice&amp;#39;]

databases.each do |database|
  formats.each do |format|
    RSpec.describe &amp;quot;#{database[:adapter].titleize} #{format}&amp;quot;, :type =&amp;gt; :model do
      include_examples format, database
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This code was based on something I cobbled together but cleaned up by &lt;a href="https://github.com/mbrookes"&gt;mbrookes&lt;/a&gt;, thanks mbrooks!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We first define a set a database configuration for our test databases.  We then loop over that, and use the &lt;code&gt;include_examples&lt;/code&gt; feature of &lt;code&gt;RSpec&lt;/code&gt;, passing in the both the output format and the database configuration that we want to test.  We have two files of examples, one which defines the &lt;code&gt;groupdate&lt;/code&gt; format, and the other which defines the &lt;code&gt;dateslices&lt;/code&gt; format.  Once again I&amp;#39;d like to point out that if you don&amp;#39;t care about SQLite3 support and want Timezone support, the &lt;a href="https://github.com/ankane/groupdate"&gt;groupdate&lt;/a&gt; is what you want.&lt;/p&gt;

&lt;p&gt;Lets look at the opening stanzas of &lt;code&gt;spec/dummy/spec/dateslice_tester.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;RSpec.shared_examples &amp;quot;dateslice&amp;quot; do |config|
  before :context do
    puts &amp;quot;Setting up #{config}&amp;quot;

    ActiveRecord::Base.establish_connection config

    puts &amp;quot;Trying to migrate&amp;quot;
    ActiveRecord::Migration.create_table :users, :force =&amp;gt; true do |t|
      t.string :name
      t.integer :score
      t.timestamp :created_at
      t.timestamp :updated_at
    end
  end

  before do
    Dateslices.output_format = :dateslice
    User.delete_all
  end

  it &amp;quot;should return items grouped by day&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RSpec.shared_examples&lt;/code&gt; is the counter part to the &lt;code&gt;include&lt;/code&gt; examples above, and when it gets called the database &lt;code&gt;config&lt;/code&gt; is passed in.  We then call  &lt;code&gt;ActiveRecord::Base.establish_connection config&lt;/code&gt; to connect &lt;code&gt;ActiveRecord&lt;/code&gt; to the database as part of the &lt;code&gt;before :context&lt;/code&gt; part of the RSpec life cycle.&lt;/p&gt;

&lt;p&gt;Next we need to actually create the database tables that we are going to run tests over. Since we are switching the databases as part of the testing process itself, it makes no sense to use &lt;code&gt;rake db:create:test&lt;/code&gt; to create the DDL, since which database would that be creating?  We need to do 3 different ones, and we certainly don&amp;#39;t want to have an elaborate process to start any of the tests if you decide to add an additional migration.  So we call a migration directly from the code, turning &lt;code&gt;:force =&amp;gt; true&lt;/code&gt; so even if it already exists we push the current definition there.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;ActiveRecord::Migration.create_table :users, :force =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then in the regular &lt;code&gt;before&lt;/code&gt; callback we make sure that the tables are cleared our ready for the next test.&lt;/p&gt;

&lt;h2 id="just-a-bit-of-activerecord"&gt;Just a bit of ActiveRecord&lt;/h2&gt;

&lt;p&gt;We&amp;#39;ve just gone through an ActiveRecord extention and that barely scratches the surface of what else you can do with Rails.  &lt;a href="https://pragprog.com/book/jvrails2/crafting-rails-4-applications"&gt;Crafting Rails 4 Applications&lt;/a&gt; is the best resource I&amp;#39;ve found to get a sense of what is possible, but when I sat down to work on something there was a lot of trial and error.  They through how they created &lt;a href="https://github.com/plataformatec/mail_form"&gt;mail_form&lt;/a&gt;, or at least a simplified version of it, that lets you use rails validations from ActiveRecord without having to back up the model with a database.  (As you might infer from the name, something that is useful for Contact forms that send out email.)  The book also goes through how Rails Engines work, which are very much like rails plugins but with additional integration points into the rails application lifecycle.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Pulling data out of Google Analytics</title>
    <link rel="alternate" href="http://willschenk.com/pulling-data-out-of-google-analytics/"/>
    <id>http://willschenk.com/pulling-data-out-of-google-analytics/</id>
    <published>2014-12-03T19:00:00-05:00</published>
    <updated>2014-12-03T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;I like staring at the real time stats of &lt;a href="http://www.google.com/analytics/"&gt;Google Analytics&lt;/a&gt;.  As a dashboard, it&amp;#39;s not really as amazing as &lt;a href="https://chartbeat.com"&gt;Chartbeat&lt;/a&gt; is, and it doesn&amp;#39;t let you drill down into the data as much as &lt;a href="https://mixpanel.com"&gt;Mixpanel&lt;/a&gt;.  But GA is super simple to setup and it&amp;#39;s Google, so everyone uses it.&lt;/p&gt;

&lt;p&gt;Another obsessive/fun thing to do is to see where that spike in inbound traffic is coming from.  On &lt;a href="http://happyfuncorp.com"&gt;HappyFunCorp&lt;/a&gt; there are days where we get a sudden influx of &lt;a href="http://happyfuncorp.com/#happy-thoughts"&gt;Happy Thoughts&lt;/a&gt; which warms our hearts and floods our inboxes.  Where did they come from?  How do we figure it out?&lt;/p&gt;

&lt;p&gt;Lets look at how we can interact with Google Analytics using &lt;a href="https://github.com/google/google-api-ruby-client"&gt;google-api-ruby-client&lt;/a&gt;.  At the end of this, we are going to be able to see the current traffic stats, top referrals, see a timeline of when the referals first came in, and do what we can from that information to track down who is talking about us.  GA will show us that we are getting a lot of &lt;code&gt;SOCIAL&lt;/code&gt; traffic, but what else can we figure out?&lt;/p&gt;

&lt;h2 id="step-1-setting-it-up-to-access-google-on-behalf-of-the-user"&gt;Step 1 Setting it up to access Google on behalf of the user&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re going to be using OAuth2 to authorize our script.  So head over to the &lt;a href="https://console.developers.google.com/project"&gt;Google Developers Console&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Create a Project&lt;/em&gt;.  You should name this something that makes sense to you.  I called my &lt;em&gt;Social Investigator&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enable the &lt;em&gt;Analytics API&lt;/em&gt;.  This can be done on the side bar, under &lt;strong&gt;APIs and auth &amp;gt; Apis&lt;/strong&gt;.  Scroll down to find it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;APIs and auth &amp;gt; Consent Screen&lt;/strong&gt;.  Create something here, you&amp;#39;ll need to flesh this out later.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;APIs and auth &amp;gt; Create Client ID&lt;/strong&gt;.  Select &lt;strong&gt;Installed Application&lt;/strong&gt; with type &lt;em&gt;Other&lt;/em&gt;.  This will create the keys for you, and then you &lt;strong&gt;Download JSON&lt;/strong&gt; and save it in a file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="step-2-getting-an-access-token-and-an-api-file-using-installedappflow"&gt;Step 2 Getting an access token and an API file using InstalledAppFlow&lt;/h2&gt;

&lt;p&gt;Working with the Google API is pretty confusing at first, since there&amp;#39;s multiple steps that need to happen before you can even figure out how to make a call.  Twitter&amp;#39;s API, which in every other way is a joke compared to Google&amp;#39;s way of doing things, has a &lt;a href="/scripting-twitter"&gt;handy way to get a single use access token&lt;/a&gt;.  With Google you need to do this yourself.  And once that&amp;#39;s done, you need to load the API meta data from the API API to be able to access it!&lt;/p&gt;

&lt;p&gt;We&amp;#39;re going to be using a few gems to put in your &lt;code&gt;Gemfile&lt;/code&gt; specifically:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;source &amp;#39;https://rubygems.org&amp;#39;

gem &amp;#39;google-api-client&amp;#39;
gem &amp;#39;thor&amp;#39;
gem &amp;#39;hirb&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can use the &lt;code&gt;Google::APIClient::InstalledAppFlow&lt;/code&gt; class to open up a web browser, have the user log in as needed to their Google Accounts, and grant access to the API.  The code below shows the basics of this.  We assume that the file you downloaded in step 1 is called &lt;code&gt;client_secrets.json&lt;/code&gt; and in the same directory, and we are writing out the granted credentials into the &lt;code&gt;analytics-oauth2.json&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;#!/usr/bin/env ruby -KU
#
# This code has been adapted from
# https://github.com/google/google-api-ruby-client-samples/tree/master/drive
#

require &amp;#39;thor&amp;#39;
require &amp;#39;hirb&amp;#39;
require &amp;#39;google/api_client&amp;#39;
require &amp;#39;google/api_client/client_secrets&amp;#39;
require &amp;#39;google/api_client/auth/file_storage&amp;#39;
require &amp;#39;google/api_client/auth/installed_app&amp;#39;
require &amp;#39;logger&amp;#39;
require &amp;#39;csv&amp;#39;

API_VERSION = &amp;#39;v3&amp;#39;
CACHED_API_FILE = &amp;quot;analytics-#{API_VERSION}.cache&amp;quot;
CREDENTIAL_STORE_FILE = &amp;quot;analytics-oauth2.json&amp;quot;
CLIENT_SECRETS_FILE = &amp;quot;client_secrets.json&amp;quot;

class AnalyticsClient
  def initialize( file_caches = nil )
    client
  end

  def client
    return @client if @client

    @client = Google::APIClient.new(:application_name =&amp;gt; &amp;#39;Analyics-CLI&amp;#39;,
        :application_version =&amp;gt; &amp;#39;1.0.0&amp;#39;)

    # FileStorage stores auth credentials in a file, so they survive multiple runs
    # of the application. This avoids prompting the user for authorization every
    # time the access token expires, by remembering the refresh token.
    # Note: FileStorage is not suitable for multi-user applications.
    file_storage = Google::APIClient::FileStorage.new(CREDENTIAL_STORE_FILE)
    if file_storage.authorization.nil?
      client_secrets = Google::APIClient::ClientSecrets.load(CLIENT_SECRETS_FILE)
      # The InstalledAppFlow is a helper class to handle the OAuth 2.0 installed
      # application flow, which ties in with FileStorage to store credentials
      # between runs.
      flow = Google::APIClient::InstalledAppFlow.new(
        :client_id =&amp;gt; client_secrets.client_id,
        :client_secret =&amp;gt; client_secrets.client_secret,
        :scope =&amp;gt; [&amp;#39;https://www.googleapis.com/auth/analytics&amp;#39;]
      )
      @client.authorization = flow.authorize(file_storage)
    else
      @client.authorization = file_storage.authorization
    end

    @client
  end
end

if __FILE__ == $0
  AnalyticsClient.new.client
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this the first time, you should be prompted to grant access to your application.  The second time it should run and exit cleanly -- it has access, but we haven&amp;#39;t asked to do anything yet.&lt;/p&gt;

&lt;h2 id="step-3-discover-the-api"&gt;Step 3 Discover the API&lt;/h2&gt;

&lt;p&gt;Google takes their software development seriously, and it shows.  Not only are there many different APIs available to use, but they all have different versions.  These endpoints are all different, and rather than have them all hard coded into the client access library, you use the &lt;em&gt;discover api&lt;/em&gt; to pull in metadata associated with it.  The following code will load up this data and cache it to the filesystem so the next access will be faster.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def api
    return @api if @api

    # Load cached discovered API, if it exists. This prevents retrieving the
    # discovery document on every run, saving a round-trip to API servers.
    if File.exists? CACHED_API_FILE
      File.open(CACHED_API_FILE) do |file|
        @api = Marshal.load(file)
      end
    else
      @api = client.discovered_api(&amp;#39;analytics&amp;#39;, API_VERSION)
      File.open(CACHED_API_FILE, &amp;#39;w&amp;#39;) do |file|
        Marshal.dump(@api, file)
      end
    end

    @api
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-4-finding-a-web-profile"&gt;Step 4 Finding a web profile&lt;/h2&gt;

&lt;p&gt;In order to pull data from an analytics account, you need to query the management API to get a list of profiles that you user has access to.  We&amp;#39;re going to collapse the differences between accounts and properties, and print them all out in a list directly.  The key variable we are looking for is going to be the profile &lt;em&gt;id&lt;/em&gt;.  This is different from the &lt;em&gt;web property id&lt;/em&gt;, which is what you use in Javascript to add the tracking code (.e.g &lt;code&gt;UA-56296045-1&lt;/code&gt;).  We&amp;#39;ll also show the &lt;em&gt;websiteUrl&lt;/em&gt; associated with the account since that&amp;#39;s what people really know.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def profiles
    client.execute(
      api_method: api.management.profiles.list,
      parameters: { accountId: &amp;quot;~all&amp;quot;, webPropertyId: &amp;quot;~all&amp;quot; } )
  end

  def print_profiles
    profiles.data.items.each do |profile|
      printf &amp;quot;%-15d %-15s %s\n&amp;quot;, profile.id, profile.webPropertyId, profile.websiteUrl
    end
  end
end

if __FILE__ == $0
  AnalyticsClient.new.print_profiles
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-5-querying-with-ga-get"&gt;Step 5 Querying with ga.get&lt;/h2&gt;

&lt;p&gt;The main end point we are looking at is &lt;code&gt;ga.get&lt;/code&gt;.  There&amp;#39;s an &lt;a href="https://ga-dev-tools.appspot.com/explorer/"&gt;interactive developer tool&lt;/a&gt; that will let you experiment with what is available and how it works.   If you load up that tool now, you&amp;#39;ll see what we&amp;#39;ve written code that will let us find the property id for our query, so we are now ready to start querying.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Query Explorer&lt;/em&gt; is really useful because of the dropdowns around &lt;em&gt;dimensions&lt;/em&gt; and &lt;em&gt;metrics&lt;/em&gt;.  When you hover over any of the fields, documentation comes up which will explain what each of the fields mean.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dimensions&lt;/em&gt; are different ways of slicing up the data.  These include things like &lt;em&gt;page title&lt;/em&gt;, &lt;em&gt;referer&lt;/em&gt;, &lt;em&gt;adwords&lt;/em&gt;, and other ways of slicing up the people that came to your site.  &lt;em&gt;Metrics&lt;/em&gt; are the actual data for these buckets of users, and include things like &lt;em&gt;sessions&lt;/em&gt;, &lt;em&gt;user counts&lt;/em&gt;, &lt;em&gt;page views&lt;/em&gt; and &lt;em&gt;average session duration&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In order to make the query we first need to setup the query parameters.  We&amp;#39;ve split that off into its own method called &lt;code&gt;query_template&lt;/code&gt;.  The required fields are &lt;em&gt;profile id&lt;/em&gt;, &lt;em&gt;start date&lt;/em&gt;, and &lt;em&gt;end date&lt;/em&gt;.  We&amp;#39;re going to setup some defaults here which we will override in other methods when we use it.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def query_template( profile_id, start_date = nil, end_date = nil )
    today = Time.now.strftime( &amp;quot;%Y-%m-%d&amp;quot; )
    {
      &amp;quot;ids&amp;quot; =&amp;gt; &amp;quot;ga:#{profile_id}&amp;quot;,
      &amp;quot;start-date&amp;quot; =&amp;gt; start_date || today,
      &amp;quot;end-date&amp;quot; =&amp;gt; end_date || today,
      &amp;quot;sort&amp;quot; =&amp;gt; &amp;quot;-ga:pageviews&amp;quot;,
      &amp;quot;dimensions&amp;quot; =&amp;gt; &amp;quot;ga:pageTitle&amp;quot;,
      &amp;quot;metrics&amp;quot; =&amp;gt; &amp;quot;ga:pageviews,ga:newUsers,ga:users&amp;quot;
    }
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our default here is that we&amp;#39;re slicing on &lt;code&gt;pageTitle&lt;/code&gt;, showing &lt;code&gt;pageviews&lt;/code&gt;, &lt;code&gt;newUsers&lt;/code&gt;, and &lt;code&gt;users&lt;/code&gt; (which include returning users).&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s do an actual query with the parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def hotcontent( profile_id, start_date = nil, end_date = nil )
    query = query_template( profile_id, start_date, end_date )
    client.execute(
      api_method: api.data.ga.get,
      parameters: query
      )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need a way to print the result.  The result that we get back has two different things, &lt;code&gt;columnHeaders&lt;/code&gt; which is a reflection of the &lt;code&gt;query&lt;/code&gt; that we passed in, and the data itself is an array of arrays in &lt;code&gt;row&lt;/code&gt;.  We&amp;#39;re using &lt;code&gt;Hirb&lt;/code&gt; helper method here to format the result.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def print_query_result( r )
    headers = r.data.columnHeaders.collect { |x| x.name }
    puts Hirb::Helpers::AutoTable.render(r.data.rows, headers: headers )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s give it a try:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;if __FILE__ == $0
  client = AnalyticsClient.new
  results = client.hotcontent ARGV[0]
  client.print_query_result results
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you&amp;#39;ve made note of your profile id above, and we can see what it looks like now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ ruby ga.rb 93249816
+--------------------------------------------------+--------------+-------------+----------+
| ga:pageTitle                                     | ga:pageviews | ga:newUsers | ga:users |
+--------------------------------------------------+--------------+-------------+----------+
| Building Sites with Middleman | Will Schenk      | 26           | 11          | 24       |
| Bootstrap: Advanced Grid Tricks | Will Schenk    | 11           | 7           | 11       |
| Making a command line utility with gems and thor | 9            | 2           | 6        |
| Will Schenk | Will Schenk                        | 9            | 2           | 5        |
| Making Yosemite Faster | Will Schenk             | 8            | 7           | 8        |
| How to track your coworkers | Will Schenk        | 6            | 1           | 6        |
| Will Schenk - How to track your coworkers        | 3            | 0           | 1        |
+--------------------------------------------------+--------------+-------------+----------+
7 rows in set
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-6-adding-more-commands"&gt;Step 6 Adding more commands&lt;/h2&gt;

&lt;p&gt;Lets create a &lt;code&gt;Thor&lt;/code&gt; class here for the things that we want to query, and then go through a implement the calls in the &lt;code&gt;AnalyticsClient&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;We want to be able to specify the timeframe for when we want the results.  It defaults to the current date, but lets add some more options for &lt;strong&gt;today&lt;/strong&gt;, &lt;strong&gt;yesterday&lt;/strong&gt;, &lt;strong&gt;recently&lt;/strong&gt; (last 7 days), and &lt;strong&gt;month&lt;/strong&gt; (last 30 days, which isn&amp;#39;t really a month but close enough.)&lt;/p&gt;

&lt;p&gt;We also want to have different output options, so we&amp;#39;ll add a &lt;strong&gt;table&lt;/strong&gt; switch, like the &lt;code&gt;Hirb&lt;/code&gt; output above, and &lt;strong&gt;csv&lt;/strong&gt; to make it easier to plug this into other tools.&lt;/p&gt;

&lt;p&gt;We&amp;#39;re going to create 4 different ways to query the data.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What content is getting traffic&lt;/li&gt;
&lt;li&gt;Who is linking to your site&lt;/li&gt;
&lt;li&gt;Who is linking to specific pages on your site&lt;/li&gt;
&lt;li&gt;A timeline of when content was published and people started linking to it&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Commands:
  ga.rb profiles                     # List Account Profiles
  ga.rb hotcontent PROFILE_ID        # Show hot content for profile id
  ga.rb referers PROFILE_ID          # Show hot content for profile id
  ga.rb content_referers PROFILE_ID  # Show hot content for profile id
  ga.rb timeline PROFILE_ID          # Show a timeline of referers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;#39;s the CLI code:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class HammerOfTheGods &amp;lt; Thor
  desc &amp;quot;profiles&amp;quot;, &amp;quot;List Account Profiles&amp;quot;
  def profiles
    client.print_profiles
  end

  desc &amp;quot;hotcontent PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv]
  def hotcontent( profile_id )
    result = client.hotcontent( profile_id, start_date, end_date )
    print_result result
  end

  desc &amp;quot;referers PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv]
  def referers( profile_id )
    result = client.referers( profile_id, start_date, end_date )
    print_result( result )
  end

  desc &amp;quot;content_referers PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv]
  def content_referers( profile_id )
    result = client.content_referers( profile_id, start_date, end_date )
    print_result( result )
  end

  desc &amp;quot;timeline PROFILE_ID&amp;quot;, &amp;quot;Show a timeline of referers&amp;quot;
  def timeline( profile_id )
    client.timeline( profile_id )
  end

  private
  def client
    @client ||= AnalyticsClient.new
  end

  def start_date
    return (Time.now - (24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:yesterday]
    return (Time.now - (7*24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:recently]
    return (Time.now - (30*24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:month]
    nil
  end

  def end_date
    return (Time.now - (24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:yesterday]
    nil
  end

  def print_result( result )
    if options[:csv]
      client.print_csv_result( result )
    else
      client.print_query_result( result )
    end
  end
end

if __FILE__ == $0
  HammerOfTheGods.start(ARGV)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-7-lets-implement"&gt;Step 7 Lets implement&lt;/h2&gt;

&lt;p&gt;We have the &lt;code&gt;profiles&lt;/code&gt; command and the &lt;code&gt;hotcontent&lt;/code&gt; command, or &lt;strong&gt;what content is getting traffic&lt;/strong&gt; working already.  Lets add some code to make the &lt;code&gt;--csv&lt;/code&gt; option work, this goes into the &lt;code&gt;AnalyticsClient&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def print_csv_result(r)
    csv_string = CSV.generate do |csv|
      csv &amp;lt;&amp;lt; r.data.columnHeaders.collect { |x| x.name }
      r.data.rows.each do |row|
        csv &amp;lt;&amp;lt; row
      end
    end

    puts csv_string
    csv_string
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Who is linking to your site&lt;/strong&gt;?
We can find out by looking at &lt;code&gt;ga:source&lt;/code&gt; which is basically the domain, &lt;code&gt;ga:referralPath&lt;/code&gt; which is the path part of the url if it&amp;#39;s a link referral, and &lt;code&gt;ga:medium&lt;/code&gt; which will tell you if it&amp;#39;s linking from a direct url, social media link, email link, or ad traffic.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def referers( profile_id, start_date = nil, end_date = nil )
    query = query_template( profile_id, start_date, end_date )
    query[&amp;quot;dimensions&amp;quot;] = &amp;quot;ga:source,ga:referralPath,ga:medium&amp;quot;
    client.execute(
      api_method: api.data.ga.get,
      parameters: query
      )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Who is linking to specific pages on your site&lt;/strong&gt; can be dertimined by adding the &lt;code&gt;ga:landingPagePath&lt;/code&gt; dimension to the above query.  This now breakdown the source of traffic not to the site as a whole, but to a specific landing page.  We&amp;#39;re also changing the &lt;code&gt;sort&lt;/code&gt; query parameter to take this additional dimension into effect.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def content_referers( profile_id, start_date = nil, end_date = nil )
    query = query_template( profile_id, start_date, end_date )
    query[&amp;quot;dimensions&amp;quot;] = &amp;quot;ga:landingPagePath,ga:source,ga:referralPath,ga:medium&amp;quot;
    query[&amp;quot;sort&amp;quot;] = &amp;quot;ga:landingPagePath,-ga:pageviews&amp;quot;

    client.execute(
      api_method: api.data.ga.get,
      parameters: query
      )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but we can change the way it&amp;#39;s printed out to be visually more useful.  In the &lt;code&gt;HammerOfTheGods&lt;/code&gt; we can flesh it out a bit, so it only prints out your local path once while listing the referals indented so you can scan and see what&amp;#39;s going on grouped by page.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;content_referers PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv, :full]
  def content_referers( profile_id )
    result = client.content_referers( profile_id, start_date, end_date )

    if options[:table] || options[:csv]
      print_result( result )
    else
      last_title = nil

      result.data.rows.each do |row|
        puts &amp;quot;\n#{row[0]}&amp;quot; if last_title != row[0]
        last_title = row[0]
        printf( &amp;quot;     %-5s %-8s %s%s\n&amp;quot;, row[4], row[3], row[1], row[2])
      end
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-8-the-timeline"&gt;Step 8 The timeline&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;A timeline of when content was published and people started linking to it&lt;/strong&gt; can be created by combinding 2 of the methods that we&amp;#39;ve already written, &lt;code&gt;hotcontent&lt;/code&gt; and &lt;code&gt;referers&lt;/code&gt;, and looping through and querying them one day at a time.&lt;/p&gt;

&lt;p&gt;We start 30 days ago, and get a list of content for that day.  If we haven&amp;#39;t seen it before, we say that it was posted that day.  We then get a list of referrals for that day.  If we haven&amp;#39;t seen them before, we print it out.  I&amp;#39;m also supressing links that have passed in less that 2 visitors, since they tend to be very noisey.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def timeline( profile_id )
    one_month_ago = Time.now - 30 * 24 * 60 * 60

    start_date = one_month_ago

    today = Time.now

    seen = {}
    title = {}
    while start_date.to_date &amp;lt;= today.to_date
      puts
      puts start_date.to_date

      contents = hotcontent( profile_id, start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ), start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ) )
      contents.data.rows.each do |content|
        unless title[content[0]]
          puts &amp;quot;  Posted:  #{content[0]}&amp;quot;
        end

        title[content[0]] = true
      end
      puts

      result = referers( profile_id, start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ), start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ) )
      result.data.rows.each do |data|
        url = data[0]
        url = &amp;quot;http://#{data[0]}#{data[1]}&amp;quot; if data[2] == &amp;#39;referral&amp;#39;
        printf &amp;quot;  %-10s %5s %s\n&amp;quot;, data[2], data[3],url if !seen[url] &amp;amp;&amp;amp; data[3].to_i &amp;gt; 2
        seen[url] = true if data[2] == &amp;#39;referral&amp;#39;
      end
      start_date = start_date + 24 * 60 * 60
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="code"&gt;Code&lt;/h2&gt;

&lt;p&gt;The &lt;a href="https://gist.github.com/wschenk/d7f8650d619d8f68730a"&gt;full code is available to play with&lt;/a&gt;.  The mechanism for talking to Google APIs from a script works everywhere, but if you are going to do this on your server you&amp;#39;ll want to get the OAuth2 key using a different process than the &lt;code&gt;InstalledAppFlow&lt;/code&gt;.&lt;/p&gt;
</content>
  </entry>
</feed>
